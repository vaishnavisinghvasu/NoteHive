{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nimport React, { useRef, useEffect, useCallback, useState, memo, forwardRef, useContext } from \"react\";\nimport { createDefer, once, uid, createIntegrationUsageDataPlugin, isCKEditorFreeLicense, appendExtraPluginsToEditorConfig, shallowCompareArrays, uniq, overwriteObject, overwriteArray, isSSR, loadCKEditorCloud } from \"@ckeditor/ckeditor5-integrations-common\";\nimport { loadCKEditorCloud as loadCKEditorCloud2 } from \"@ckeditor/ckeditor5-integrations-common\";\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nconst _LifeCycleElementSemaphore = class _LifeCycleElementSemaphore {\n  constructor(element, lifecycle) {\n    /**\n     * This should define async methods for initializing and destroying the editor.\n     * Essentially, it's an async version of basic React lifecycle methods like `componentDidMount`, `componentWillUnmount`.\n     *\n     * \t* Result of {@link LifeCycleAsyncOperators#mount} method is passed to {@link LifeCycleAsyncOperators#unmount} as an argument.\n     */\n    __publicField(this, \"_lifecycle\");\n    /**\n     * This is the element instance that the editor uses for mounting. This element should contain the `ckeditorInstance` member\n     * once the editor has been successfully mounted to it. The semaphore ensures that a new instance of the editor, which will\n     * be assigned to this element by the {@link #_lifecycle:mount} method, will always be initialized after the successful\n     * destruction of the underlying `ckeditorInstance` that was previously mounted on this element.\n     */\n    __publicField(this, \"_element\");\n    /**\n     * This is the lock mechanism utilized by the {@link #lock} and {@link #release} methods.\n     *\n     * \t* If the editor is not yet mounted and is awaiting mounting (for instance, when another editor is\n     * \t  occupying the element), then it is null.\n     *\n     * \t* When the editor is mounted on the element, this variable holds an unresolved promise that will be\n     * \t  resolved after the editor is destroyed.\n     *\n     * \t* Once the editor is destroyed (and it was previously mounted), the promise is resolved.\n     */\n    __publicField(this, \"_releaseLock\", null);\n    /**\n     * This is the result of the {@link #_lifecycle:mount} function. This value should be reset to `null`\n     * once the semaphore is released. It is utilized to store certain data that must be removed following\n     * the destruction of the editor. This data may include the editor's instance, the assigned watchdog,\n     * or handles for additional window listeners.\n     */\n    __publicField(this, \"_value\", null);\n    /**\n     * This is a list of callbacks that are triggered if the semaphore {@link #_lifecycle:mount} method executes successfully.\n     * It is utilized in scenarios where we need to assign certain properties to an editor that is currently in the process of mounting.\n     * An instance of such usage could be two-way binding. We aim to prevent the loss of all `setData` calls if the editor has not\n     * yet been mounted, therefore these calls will be executed immediately following the completion of the mounting process.\n     */\n    __publicField(this, \"_afterMountCallbacks\", []);\n    /**\n     * This represents the actual mounting state of the semaphore. It is primarily used by the {@link #release} method to\n     * determine whether the initialization of the editor should be skipped or, if the editor is already initialized, the editor\n     * should be destroyed.\n     *\n     * \t* If `destroyedBeforeInitialization` is true, then the {@link #release} method was invoked before the editor began to mount.\n     * \t  This often occurs in strict mode when we assign a promise to the {@link LifeCycleEditorElementSemaphore#_semaphores} map\n     * \t  and the assigned `mount` callback has not yet been called. In this scenario, it is safe to skip the initialization of the editor\n     * \t  and simply release the semaphore.\n     *\n     *\t* If `mountingInProgress` is a Promise, then the {@link #release} method was invoked after the initialization of the editor and\n     \t  the editor must be destroyed before the semaphore is released.\n    */\n    __publicField(this, \"_state\", {\n      destroyedBeforeInitialization: false,\n      mountingInProgress: null\n    });\n    /**\n     * Inverse of {@link #_lock} method that tries to destroy attached editor.\n     *\n     * \t* If editor is being already attached to element (or is in attaching process) then after fully initialization of editor\n     * \t  destroy is performed and semaphore is released. The {@link #_lifecycle} unmount method is called.\n     *\n     * \t* If editor is being destroyed before initialization then it does nothing but sets `destroyedBeforeInitialization` flag that\n     * \t  will be later checked by {@link #_lock} method in initialization. The {@link #_lifecycle} unmount method is not called.\n     *\n     * *Important note:*\n     *\n     * It’s really important to keep this method *sync*. If we make this method *async*, it won’t work well because\n     * it will cause problems when we’re trying to set up the {@link LifeCycleEditorElementSemaphore#_semaphores} map entries.\n     */\n    __publicField(this, \"release\", once(() => {\n      const {\n        _releaseLock,\n        _state,\n        _element,\n        _lifecycle\n      } = this;\n      if (_state.mountingInProgress) {\n        _state.mountingInProgress.then(() => _lifecycle.unmount({\n          element: _element,\n          // Mount result might be overridden by watchdog during restart so use instance variable.\n          mountResult: this.value\n        })).catch(error => {\n          console.error(\"Semaphore unmounting error:\", error);\n        }).then(_releaseLock.resolve).then(() => {\n          this._value = null;\n        });\n      } else {\n        _state.destroyedBeforeInitialization = true;\n        _releaseLock.resolve();\n      }\n    }));\n    this._element = element;\n    this._lifecycle = lifecycle;\n    this._lock();\n  }\n  /**\n   * Getter for {@link #_value}.\n   */\n  get value() {\n    return this._value;\n  }\n  /**\n   * Occasionally, the Watchdog restarts the editor instance, resulting in a new instance being assigned to the semaphore.\n   * In terms of race conditions, it's generally safer to simply override the semaphore value rather than recreating it\n   * with a different one.\n   */\n  unsafeSetValue(value) {\n    this._value = value;\n    this._afterMountCallbacks.forEach(callback => callback(value));\n    this._afterMountCallbacks = [];\n  }\n  /**\n   * This registers a callback that will be triggered after the editor has been successfully mounted.\n   *\n   * \t* If the editor is already mounted, the callback will be executed immediately.\n   *\t* If the editor is in the process of mounting, the callback will be executed upon successful mounting.\n  * \t* If the editor is never mounted, the passed callback will not be executed.\n  * \t* If an exception is thrown within the callback, it will be re-thrown in the semaphore.\n  */\n  runAfterMount(callback) {\n    const {\n      _value,\n      _afterMountCallbacks\n    } = this;\n    if (_value) {\n      callback(_value);\n    } else {\n      _afterMountCallbacks.push(callback);\n    }\n  }\n  /**\n   * This method is used to inform other components that the {@link #_element} will be used by the editor,\n   * which is initialized by the {@link #_lifecycle} methods.\n   *\n   * \t* If an editor is already present on the provided element, the initialization of the current one\n   * \t  will be postponed until the previous one is destroyed.\n   *\n   * \t* If the element is empty and does not have an editor attached to it, the currently locked editor will\n   * \t  be mounted immediately.\n   *\n   * After the successful initialization of the editor and the assignment of the {@link #_value} member,\n   * the `onReady` lifecycle method is called.\n   *\n   * *Important note:*\n   *\n   * It’s really important to keep this method *sync*. If we make this method *async*, it won’t work well because\n   * it will cause problems when we’re trying to set up the {@link LifeCycleEditorElementSemaphore#_semaphores} map entries.\n   */\n  _lock() {\n    const {\n      _semaphores\n    } = _LifeCycleElementSemaphore;\n    const {\n      _state,\n      _element,\n      _lifecycle\n    } = this;\n    const prevElementSemaphore = _semaphores.get(_element) || Promise.resolve(null);\n    const releaseLock = createDefer();\n    this._releaseLock = releaseLock;\n    const newElementSemaphore = prevElementSemaphore.then(() => {\n      if (_state.destroyedBeforeInitialization) {\n        return Promise.resolve(void 0);\n      }\n      _state.mountingInProgress = _lifecycle.mount().then(mountResult => {\n        if (mountResult) {\n          this.unsafeSetValue(mountResult);\n        }\n        return mountResult;\n      });\n      return _state.mountingInProgress;\n    }).then(async mountResult => {\n      if (mountResult && _lifecycle.afterMount) {\n        await _lifecycle.afterMount({\n          element: _element,\n          mountResult\n        });\n      }\n    }).then(() => releaseLock.promise).catch(error => {\n      console.error(\"Semaphore mounting error:\", error);\n    }).then(() => {\n      if (_semaphores.get(_element) === newElementSemaphore) {\n        _semaphores.delete(_element);\n      }\n    });\n    _semaphores.set(_element, newElementSemaphore);\n  }\n};\n/**\n * This is a map of elements associated with promises. It informs the semaphore that the underlying HTML element, used as a key,\n * is currently in use by another editor. Each element is assigned a promise, which allows for the easy chaining of new\n * editor instances on an element that is already in use by another instance. The process works as follows:\n *\n * \t1. If an element is being used by an editor, then the initialization of a new editor\n * \t   instance is chained using the `.then()` method of the Promise.\n *\n * \t2. If the editor associated with the underlying element is destroyed, then `Promise.resolve()` is called\n * \t   and the previously assigned `.then()` editor callback is executed.\n *\n *  @see {@link #lock} for more detailed information on the implementation.\n */\n__publicField(_LifeCycleElementSemaphore, \"_semaphores\", /* @__PURE__ */new Map());\nlet LifeCycleElementSemaphore = _LifeCycleElementSemaphore;\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nconst ReactContextMetadataKey = \"$__CKEditorReactContextMetadata\";\nfunction withCKEditorReactContextMetadata(metadata, config) {\n  return {\n    ...config,\n    [ReactContextMetadataKey]: metadata\n  };\n}\nfunction tryExtractCKEditorReactContextMetadata(object) {\n  return object.get(ReactContextMetadataKey);\n}\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nconst useIsMountedRef = () => {\n  const mountedRef = useRef(false);\n  useEffect(() => {\n    mountedRef.current = true;\n    return () => {\n      mountedRef.current = false;\n    };\n  }, []);\n  return mountedRef;\n};\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nconst useRefSafeCallback = fn => {\n  const callbackRef = useRef();\n  callbackRef.current = fn;\n  return useCallback((...args) => callbackRef.current(...args), []);\n};\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nconst useInitializedCKEditorsMap = ({\n  currentContextWatchdog,\n  onChangeInitializedEditors\n}) => {\n  const onChangeInitializedEditorsSafe = useRefSafeCallback(onChangeInitializedEditors || (() => {}));\n  useEffect(() => {\n    var _a;\n    if (currentContextWatchdog.status !== \"initialized\") {\n      return;\n    }\n    const {\n      watchdog\n    } = currentContextWatchdog;\n    const editors = (_a = watchdog == null ? void 0 : watchdog.context) == null ? void 0 : _a.editors;\n    if (!editors) {\n      return;\n    }\n    const getInitializedContextEditors = () => [...editors].reduce((map, editor) => {\n      var _a2;\n      if (editor.state !== \"ready\") {\n        return map;\n      }\n      const metadata = tryExtractCKEditorReactContextMetadata(editor.config);\n      const nameOrId = (_a2 = metadata == null ? void 0 : metadata.name) != null ? _a2 : editor.id;\n      map[nameOrId] = {\n        instance: editor,\n        metadata\n      };\n      return map;\n    }, /* @__PURE__ */Object.create({})\n    // Prevent the prototype pollution.\n    );\n    const onEditorStatusChange = () => {\n      onChangeInitializedEditorsSafe(getInitializedContextEditors(), watchdog);\n    };\n    const trackEditorLifecycle = editor => {\n      editor.once(\"ready\", onEditorStatusChange, {\n        priority: \"lowest\"\n      });\n      editor.once(\"destroy\", onEditorStatusChange, {\n        priority: \"lowest\"\n      });\n    };\n    const onAddEditorToCollection = (_, editor) => {\n      trackEditorLifecycle(editor);\n    };\n    editors.forEach(trackEditorLifecycle);\n    editors.on(\"add\", onAddEditorToCollection);\n    if (Array.from(editors).some(editor => editor.state === \"ready\")) {\n      onEditorStatusChange();\n    }\n    return () => {\n      editors.off(\"add\", onAddEditorToCollection);\n    };\n  }, [currentContextWatchdog]);\n};\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nconst ContextWatchdogContext = React.createContext(null);\nconst CKEditorContext = props => {\n  const {\n    id,\n    context,\n    watchdogConfig,\n    children,\n    config,\n    onReady,\n    contextWatchdog: ContextWatchdogConstructor,\n    isLayoutReady = true,\n    onChangeInitializedEditors,\n    onError = (error, details) => console.error(error, details)\n  } = props;\n  const isMountedRef = useIsMountedRef();\n  const prevWatchdogInitializationIDRef = useRef(null);\n  const [currentContextWatchdog, setCurrentContextWatchdog] = useState({\n    status: \"initializing\"\n  });\n  useEffect(() => {\n    if (isLayoutReady) {\n      initializeContextWatchdog();\n    } else {\n      setCurrentContextWatchdog({\n        status: \"initializing\"\n      });\n    }\n  }, [id, isLayoutReady]);\n  useEffect(() => () => {\n    if (currentContextWatchdog.status === \"initialized\") {\n      currentContextWatchdog.watchdog.destroy();\n    }\n  }, [currentContextWatchdog]);\n  useInitializedCKEditorsMap({\n    currentContextWatchdog,\n    onChangeInitializedEditors\n  });\n  function regenerateInitializationID() {\n    prevWatchdogInitializationIDRef.current = uid();\n    return prevWatchdogInitializationIDRef.current;\n  }\n  function canUpdateState(initializationID) {\n    return prevWatchdogInitializationIDRef.current === initializationID && isMountedRef.current;\n  }\n  function initializeContextWatchdog() {\n    const watchdogInitializationID = regenerateInitializationID();\n    const contextWatchdog = new ContextWatchdogConstructor(context, watchdogConfig);\n    contextWatchdog.on(\"error\", (_, errorEvent) => {\n      /* istanbul ignore else -- @preserve */\n      if (canUpdateState(watchdogInitializationID)) {\n        onError(errorEvent.error, {\n          phase: \"runtime\",\n          willContextRestart: errorEvent.causesRestart\n        });\n      }\n    });\n    contextWatchdog.on(\"stateChange\", () => {\n      if (onReady && contextWatchdog.state === \"ready\" && canUpdateState(watchdogInitializationID)) {\n        onReady(contextWatchdog.context, contextWatchdog);\n      }\n    });\n    contextWatchdog.create(config).then(() => {\n      if (canUpdateState(watchdogInitializationID)) {\n        setCurrentContextWatchdog({\n          status: \"initialized\",\n          watchdog: contextWatchdog\n        });\n      } else {\n        contextWatchdog.destroy();\n      }\n    }).catch(error => {\n      if (canUpdateState(watchdogInitializationID)) {\n        onError(error, {\n          phase: \"initialization\",\n          willContextRestart: false\n        });\n        setCurrentContextWatchdog({\n          status: \"error\",\n          error\n        });\n      }\n    });\n    return contextWatchdog;\n  }\n  return /* @__PURE__ */React.createElement(ContextWatchdogContext.Provider, {\n    value: currentContextWatchdog\n  }, children);\n};\nconst isContextWatchdogValue = obj => !!obj && typeof obj === \"object\" && \"status\" in obj && [\"initializing\", \"initialized\", \"error\"].includes(obj.status);\nconst isContextWatchdogValueWithStatus = status => obj => isContextWatchdogValue(obj) && obj.status === status;\nconst isContextWatchdogInitializing = isContextWatchdogValueWithStatus(\"initializing\");\nconst isContextWatchdogReadyToUse = obj => isContextWatchdogValueWithStatus(\"initialized\")(obj) && obj.watchdog.state === \"ready\";\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nconst ReactIntegrationUsageDataPlugin = createIntegrationUsageDataPlugin(\"react\", {\n  version: \"9.5.0\",\n  frameworkVersion: React.version\n});\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nfunction appendAllIntegrationPluginsToConfig(editorConfig) {\n  if (isCKEditorFreeLicense(editorConfig.licenseKey)) {\n    return editorConfig;\n  }\n  return appendExtraPluginsToEditorConfig(editorConfig, [\n  /**\n   * This part of the code is not executed in open-source implementations using a GPL key.\n   * It only runs when a specific license key is provided. If you are uncertain whether\n   * this applies to your installation, please contact our support team.\n   */\n  ReactIntegrationUsageDataPlugin]);\n}\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nconst REACT_INTEGRATION_READ_ONLY_LOCK_ID$1 = \"Lock from React integration (@ckeditor/ckeditor5-react)\";\nclass CKEditor extends React.Component {\n  constructor(props) {\n    super(props);\n    /**\n     * After mounting the editor, the variable will contain a reference to the created editor.\n     * @see: https://ckeditor.com/docs/ckeditor5/latest/api/module_core_editor_editor-Editor.html\n     */\n    __publicField(this, \"domContainer\", React.createRef());\n    /**\n     * Unlocks element in editor semaphore after destroy editor instance.\n     */\n    __publicField(this, \"editorSemaphore\", null);\n    this._checkVersion();\n  }\n  /**\n   * Checks if the CKEditor version used in the application is compatible with the component.\n   */\n  _checkVersion() {\n    const {\n      CKEDITOR_VERSION\n    } = window;\n    if (!CKEDITOR_VERSION) {\n      return console.warn('Cannot find the \"CKEDITOR_VERSION\" in the \"window\" scope.');\n    }\n    const [major] = CKEDITOR_VERSION.split(\".\").map(Number);\n    if (major >= 42 || CKEDITOR_VERSION.startsWith(\"0.0.0\")) {\n      return;\n    }\n    console.warn(\"The <CKEditor> component requires using CKEditor 5 in version 42+ or nightly build.\");\n  }\n  get _semaphoreValue() {\n    const {\n      editorSemaphore\n    } = this;\n    return editorSemaphore ? editorSemaphore.value : null;\n  }\n  /**\n   * An watchdog instance.\n   */\n  get watchdog() {\n    const {\n      _semaphoreValue\n    } = this;\n    return _semaphoreValue ? _semaphoreValue.watchdog : null;\n  }\n  /**\n   * An editor instance.\n   */\n  get editor() {\n    const {\n      _semaphoreValue\n    } = this;\n    return _semaphoreValue ? _semaphoreValue.instance : null;\n  }\n  /**\n   * The CKEditor component should not be updated by React itself.\n   * However, if the component identifier changes, the whole structure should be created once again.\n   */\n  shouldComponentUpdate(nextProps) {\n    const {\n      props,\n      editorSemaphore\n    } = this;\n    if (nextProps.id !== props.id) {\n      return true;\n    }\n    if (nextProps.disableWatchdog !== props.disableWatchdog) {\n      return true;\n    }\n    if (editorSemaphore) {\n      editorSemaphore.runAfterMount(({\n        instance\n      }) => {\n        if (this._shouldUpdateEditorData(props, nextProps, instance)) {\n          instance.data.set(nextProps.data);\n        }\n      });\n      if (\"disabled\" in nextProps) {\n        editorSemaphore.runAfterMount(({\n          instance\n        }) => {\n          if (nextProps.disabled) {\n            instance.enableReadOnlyMode(REACT_INTEGRATION_READ_ONLY_LOCK_ID$1);\n          } else {\n            instance.disableReadOnlyMode(REACT_INTEGRATION_READ_ONLY_LOCK_ID$1);\n          }\n        });\n      }\n    }\n    return false;\n  }\n  /**\n   * Initialize the editor when the component is mounted.\n   */\n  componentDidMount() {\n    if (!isContextWatchdogInitializing(this.context)) {\n      this._initLifeCycleSemaphore();\n    }\n  }\n  /**\n   * Re-render the entire component once again. The old editor will be destroyed and the new one will be created.\n   */\n  componentDidUpdate() {\n    if (!isContextWatchdogInitializing(this.context)) {\n      this._initLifeCycleSemaphore();\n    }\n  }\n  /**\n   * Destroy the editor before unmounting the component.\n   */\n  componentWillUnmount() {\n    this._unlockLifeCycleSemaphore();\n  }\n  /**\n   * Async destroy attached editor and unlock element semaphore.\n   */\n  _unlockLifeCycleSemaphore() {\n    if (this.editorSemaphore) {\n      this.editorSemaphore.release();\n      this.editorSemaphore = null;\n    }\n  }\n  /**\n   * Unlocks previous editor semaphore and creates new one..\n   */\n  _initLifeCycleSemaphore() {\n    this._unlockLifeCycleSemaphore();\n    this.editorSemaphore = new LifeCycleElementSemaphore(this.domContainer.current, {\n      mount: async () => this._initializeEditor(),\n      afterMount: ({\n        mountResult\n      }) => {\n        const {\n          onReady\n        } = this.props;\n        if (onReady && this.domContainer.current !== null) {\n          onReady(mountResult.instance);\n        }\n      },\n      unmount: async ({\n        element,\n        mountResult\n      }) => {\n        const {\n          onAfterDestroy\n        } = this.props;\n        try {\n          await this._destroyEditor(mountResult);\n          element.innerHTML = \"\";\n        } finally {\n          if (onAfterDestroy) {\n            onAfterDestroy(mountResult.instance);\n          }\n        }\n      }\n    });\n  }\n  /**\n   * Render a <div> element which will be replaced by CKEditor.\n   */\n  render() {\n    return /* @__PURE__ */React.createElement(\"div\", {\n      ref: this.domContainer\n    });\n  }\n  /**\n   * Initializes the editor by creating a proper watchdog and initializing it with the editor's configuration.\n   */\n  async _initializeEditor() {\n    if (this.props.disableWatchdog) {\n      const instance = await this._createEditor(this.domContainer.current, this._getConfig());\n      return {\n        instance,\n        watchdog: null\n      };\n    }\n    const watchdog = (() => {\n      if (isContextWatchdogReadyToUse(this.context)) {\n        return new EditorWatchdogAdapter(this.context.watchdog);\n      }\n      return new this.props.editor.EditorWatchdog(this.props.editor, this.props.watchdogConfig);\n    })();\n    const totalRestartsRef = {\n      current: 0\n    };\n    watchdog.setCreator(async (el, config) => {\n      var _a;\n      const {\n        editorSemaphore\n      } = this;\n      const {\n        onAfterDestroy\n      } = this.props;\n      if (totalRestartsRef.current > 0 && onAfterDestroy && ((_a = editorSemaphore == null ? void 0 : editorSemaphore.value) == null ? void 0 : _a.instance)) {\n        onAfterDestroy(editorSemaphore.value.instance);\n      }\n      const instance = await this._createEditor(el, config);\n      if (editorSemaphore && totalRestartsRef.current > 0) {\n        editorSemaphore.unsafeSetValue({\n          instance,\n          watchdog\n        });\n        setTimeout(() => {\n          if (this.props.onReady) {\n            this.props.onReady(watchdog.editor);\n          }\n        });\n      }\n      totalRestartsRef.current++;\n      return instance;\n    });\n    watchdog.on(\"error\", (_, {\n      error,\n      causesRestart\n    }) => {\n      const onError = this.props.onError || console.error;\n      onError(error, {\n        phase: \"runtime\",\n        willEditorRestart: causesRestart\n      });\n    });\n    await watchdog.create(this.domContainer.current, this._getConfig()).catch(error => {\n      const onError = this.props.onError || console.error;\n      onError(error, {\n        phase: \"initialization\",\n        willEditorRestart: false\n      });\n    });\n    return {\n      watchdog,\n      instance: watchdog.editor\n    };\n  }\n  /**\n   * Creates an editor from the element and configuration.\n   *\n   * @param element The source element.\n   * @param config CKEditor 5 editor configuration.\n   */\n  _createEditor(element, config) {\n    const {\n      contextItemMetadata\n    } = this.props;\n    if (contextItemMetadata) {\n      config = withCKEditorReactContextMetadata(contextItemMetadata, config);\n    }\n    return this.props.editor.create(element, appendAllIntegrationPluginsToConfig(config)).then(editor => {\n      if (\"disabled\" in this.props) {\n        /* istanbul ignore else -- @preserve */\n        if (this.props.disabled) {\n          editor.enableReadOnlyMode(REACT_INTEGRATION_READ_ONLY_LOCK_ID$1);\n        }\n      }\n      const modelDocument = editor.model.document;\n      const viewDocument = editor.editing.view.document;\n      modelDocument.on(\"change:data\", event => {\n        /* istanbul ignore else -- @preserve */\n        if (this.props.onChange) {\n          this.props.onChange(event, editor);\n        }\n      });\n      viewDocument.on(\"focus\", event => {\n        /* istanbul ignore else -- @preserve */\n        if (this.props.onFocus) {\n          this.props.onFocus(event, editor);\n        }\n      });\n      viewDocument.on(\"blur\", event => {\n        /* istanbul ignore else -- @preserve */\n        if (this.props.onBlur) {\n          this.props.onBlur(event, editor);\n        }\n      });\n      return editor;\n    });\n  }\n  /**\n   * Destroys the editor by destroying the watchdog.\n   */\n  async _destroyEditor(initializeResult) {\n    const {\n      watchdog,\n      instance\n    } = initializeResult;\n    return new Promise((resolve, reject) => {\n      /* istanbul ignore next -- @preserve */\n      setTimeout(async () => {\n        try {\n          if (watchdog) {\n            await watchdog.destroy();\n            return resolve();\n          }\n          if (instance) {\n            await instance.destroy();\n            return resolve();\n          }\n          resolve();\n        } catch (e) {\n          console.error(e);\n          reject(e);\n        }\n      });\n    });\n  }\n  /**\n   * Returns true when the editor should be updated.\n   *\n   * @param prevProps Previous react's properties.\n   * @param nextProps React's properties.\n   * @param editor Current editor instance.\n   */\n  _shouldUpdateEditorData(prevProps, nextProps, editor) {\n    if (prevProps.data === nextProps.data) {\n      return false;\n    }\n    if (editor.data.get() === nextProps.data) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Returns the editor configuration.\n   */\n  _getConfig() {\n    const config = this.props.config || {};\n    if (this.props.data && config.initialData) {\n      console.warn(\"Editor data should be provided either using `config.initialData` or `content` property. The config value takes precedence over `content` property and will be used when both are specified.\");\n    }\n    return {\n      ...config,\n      initialData: config.initialData || this.props.data || \"\"\n    };\n  }\n}\n__publicField(CKEditor, \"contextType\", ContextWatchdogContext);\nclass EditorWatchdogAdapter {\n  /**\n   * @param contextWatchdog The context watchdog instance that will be wrapped into editor watchdog API.\n   */\n  constructor(contextWatchdog) {\n    /**\n     * The context watchdog instance that will be wrapped into editor watchdog API.\n     */\n    __publicField(this, \"_contextWatchdog\");\n    /**\n     * A unique id for the adapter to distinguish editor items when using the context watchdog API.\n     */\n    __publicField(this, \"_id\");\n    /**\n     * A watchdog's editor creator function.\n     */\n    __publicField(this, \"_creator\");\n    this._contextWatchdog = contextWatchdog;\n    this._id = uid();\n  }\n  /**\n   *  @param creator A watchdog's editor creator function.\n   */\n  setCreator(creator) {\n    this._creator = creator;\n  }\n  /**\n   * Adds an editor configuration to the context watchdog registry. Creates an instance of it.\n   *\n   * @param sourceElementOrData A source element or data for the new editor.\n   * @param config CKEditor 5 editor config.\n   */\n  create(sourceElementOrData, config) {\n    return this._contextWatchdog.add({\n      sourceElementOrData,\n      config,\n      creator: this._creator,\n      id: this._id,\n      type: \"editor\"\n    });\n  }\n  /**\n   * Creates a listener that is attached to context watchdog's item and run when the context watchdog fires.\n   * Currently works only for the `error` event.\n   */\n  on(_, callback) {\n    this._contextWatchdog.on(\"itemError\", (_2, {\n      itemId,\n      error\n    }) => {\n      if (itemId === this._id) {\n        callback(null, {\n          error,\n          causesRestart: void 0\n        });\n      }\n    });\n  }\n  destroy() {\n    if (this._contextWatchdog.state === \"ready\") {\n      return this._contextWatchdog.remove(this._id);\n    }\n    return Promise.resolve();\n  }\n  /**\n   * An editor instance.\n   */\n  get editor() {\n    return this._contextWatchdog.getItem(this._id);\n  }\n}\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nconst useLifeCycleSemaphoreSyncRef = () => {\n  const semaphoreRef = useRef(null);\n  const [revision, setRevision] = useState(() => Date.now());\n  const refresh = () => {\n    setRevision(Date.now());\n  };\n  const release = (rerender = true) => {\n    if (semaphoreRef.current) {\n      semaphoreRef.current.release();\n      semaphoreRef.current = null;\n    }\n    if (rerender) {\n      setRevision(Date.now());\n    }\n  };\n  const unsafeSetValue = value => {\n    var _a;\n    (_a = semaphoreRef.current) == null ? void 0 : _a.unsafeSetValue(value);\n    refresh();\n  };\n  const runAfterMount = callback => {\n    if (semaphoreRef.current) {\n      semaphoreRef.current.runAfterMount(callback);\n    }\n  };\n  const replace = newSemaphore => {\n    release(false);\n    semaphoreRef.current = newSemaphore();\n    refresh();\n    runAfterMount(refresh);\n  };\n  const createAttributeRef = key => ({\n    get current() {\n      if (!semaphoreRef.current || !semaphoreRef.current.value) {\n        return null;\n      }\n      return semaphoreRef.current.value[key];\n    }\n  });\n  return {\n    get current() {\n      return semaphoreRef.current;\n    },\n    revision,\n    createAttributeRef,\n    unsafeSetValue,\n    release,\n    replace,\n    runAfterMount\n  };\n};\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nfunction mergeRefs(...refs) {\n  return value => {\n    refs.forEach(ref => {\n      if (typeof ref === \"function\") {\n        ref(value);\n      } else if (ref != null) {\n        ref.current = value;\n      }\n    });\n  };\n}\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nconst useInstantEffect = (fn, deps) => {\n  const [prevDeps, setDeps] = useState(null);\n  if (!shallowCompareArrays(prevDeps, deps)) {\n    fn();\n    setDeps([...deps]);\n  }\n};\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nconst useInstantEditorEffect = (semaphore, fn, deps) => {\n  useInstantEffect(() => {\n    if (semaphore) {\n      semaphore.runAfterMount(fn);\n    }\n  }, [semaphore, ...deps]);\n};\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nconst REACT_INTEGRATION_READ_ONLY_LOCK_ID = \"Lock from React integration (@ckeditor/ckeditor5-react)\";\nconst useMultiRootEditor = props => {\n  const semaphoreElementRef = useRef(props.semaphoreElement || null);\n  const semaphore = useLifeCycleSemaphoreSyncRef();\n  const editorRefs = {\n    watchdog: semaphore.createAttributeRef(\"watchdog\"),\n    instance: semaphore.createAttributeRef(\"instance\")\n  };\n  const context = useContext(ContextWatchdogContext);\n  const [roots, setRoots] = useState(() => Object.keys(props.data));\n  const [data, setData] = useState({\n    ...props.data\n  });\n  const [attributes, setAttributes] = useState({\n    ...props.rootsAttributes\n  });\n  const shouldUpdateEditor = useRef(true);\n  const forceAssignFakeEditableElements = () => {\n    const editor = editorRefs.instance.current;\n    if (!editor) {\n      return;\n    }\n    const initializeEditableWithFakeElement = editable => {\n      if (editable.name && !editor.editing.view.getDomRoot(editable.name)) {\n        editor.editing.view.attachDomRoot(document.createElement(\"div\"), editable.name);\n      }\n    };\n    Object.values(editor.ui.view.editables).forEach(initializeEditableWithFakeElement);\n  };\n  useEffect(() => {\n    const semaphoreElement = semaphoreElementRef.current;\n    if (context && !isContextWatchdogReadyToUse(context)) {\n      return;\n    }\n    if (!semaphoreElement || props.isLayoutReady === false) {\n      return;\n    }\n    semaphore.replace(() => new LifeCycleElementSemaphore(semaphoreElement, {\n      mount: _initializeEditor,\n      afterMount: ({\n        mountResult\n      }) => {\n        const {\n          onReady\n        } = props;\n        if (onReady && semaphoreElementRef.current !== null) {\n          onReady(mountResult.instance);\n        }\n      },\n      unmount: async ({\n        element,\n        mountResult\n      }) => {\n        const {\n          onAfterDestroy\n        } = props;\n        try {\n          await _destroyEditor(mountResult);\n          element.innerHTML = \"\";\n        } finally {\n          if (onAfterDestroy) {\n            onAfterDestroy(mountResult.instance);\n          }\n        }\n      }\n    }));\n    return () => {\n      forceAssignFakeEditableElements();\n      semaphore.release(false);\n    };\n  }, [props.id, props.isLayoutReady, context == null ? void 0 : context.status]);\n  const _getConfig = () => {\n    const config = props.config || {};\n    if (props.data && config.initialData) {\n      console.warn(\"Editor data should be provided either using `config.initialData` or `data` property. The config value takes precedence over `data` property and will be used when both are specified.\");\n    }\n    return {\n      ...config,\n      rootsAttributes: attributes\n    };\n  };\n  const onChangeData = useRefSafeCallback((editor, event) => {\n    const modelDocument = editor.model.document;\n    if (!props.disableTwoWayDataBinding) {\n      const newData = {};\n      const newAttributes = {};\n      modelDocument.differ.getChanges().forEach(change => {\n        let root;\n        /* istanbul ignore else -- @preserve */\n        if (change.type == \"insert\" || change.type == \"remove\") {\n          root = change.position.root;\n        } else {\n          root = change.range.root;\n        }\n        if (!root.isAttached()) {\n          return;\n        }\n        const {\n          rootName\n        } = root;\n        newData[rootName] = editor.getData({\n          rootName\n        });\n      });\n      modelDocument.differ.getChangedRoots().forEach(changedRoot => {\n        if (changedRoot.state) {\n          if (newData[changedRoot.name] !== void 0) {\n            delete newData[changedRoot.name];\n          }\n          return;\n        }\n        const rootName = changedRoot.name;\n        newAttributes[rootName] = editor.getRootAttributes(rootName);\n      });\n      if (Object.keys(newData).length) {\n        setData(previousData => ({\n          ...previousData,\n          ...newData\n        }));\n      }\n      if (Object.keys(newAttributes).length) {\n        setAttributes(previousAttributes => ({\n          ...previousAttributes,\n          ...newAttributes\n        }));\n      }\n    }\n    /* istanbul ignore else -- @preserve */\n    if (props.onChange) {\n      props.onChange(event, editor);\n    }\n  });\n  const onAddRoot = useRefSafeCallback((editor, _evt, root) => {\n    const rootName = root.rootName;\n    if (!props.disableTwoWayDataBinding) {\n      setData(previousData => ({\n        ...previousData,\n        [rootName]: editor.getData({\n          rootName\n        })\n      }));\n      setAttributes(previousAttributes => ({\n        ...previousAttributes,\n        [rootName]: editor.getRootAttributes(rootName)\n      }));\n    }\n    setRoots(prevRoots => uniq([...prevRoots, root.rootName]));\n  });\n  const onDetachRoot = useRefSafeCallback((_editor, _evt, root) => {\n    const rootName = root.rootName;\n    if (!props.disableTwoWayDataBinding) {\n      setData(previousData => {\n        const {\n          [rootName]: _,\n          ...newData\n        } = previousData;\n        return {\n          ...newData\n        };\n      });\n      setAttributes(previousAttributes => {\n        const {\n          [rootName]: _,\n          ...newAttributes\n        } = previousAttributes;\n        return {\n          ...newAttributes\n        };\n      });\n    }\n    setRoots(prevRoots => prevRoots.filter(root2 => root2 !== rootName));\n  });\n  const _createEditor = useRefSafeCallback((initialData, config) => {\n    overwriteObject({\n      ...props.rootsAttributes\n    }, attributes);\n    overwriteObject({\n      ...props.data\n    }, data);\n    overwriteArray(Object.keys(props.data), roots);\n    return props.editor.create(initialData, appendAllIntegrationPluginsToConfig(config)).then(editor => {\n      const editorData = editor.getFullData();\n      overwriteObject({\n        ...editorData\n      }, data);\n      overwriteObject({\n        ...editor.getRootsAttributes()\n      }, attributes);\n      overwriteArray(Object.keys(editorData), roots);\n      if (props.disabled) {\n        /* istanbul ignore else -- @preserve */\n        editor.enableReadOnlyMode(REACT_INTEGRATION_READ_ONLY_LOCK_ID);\n      }\n      const modelDocument = editor.model.document;\n      const viewDocument = editor.editing.view.document;\n      modelDocument.on(\"change:data\", evt => onChangeData(editor, evt));\n      editor.on(\"addRoot\", (evt, root) => onAddRoot(editor, evt, root));\n      editor.on(\"detachRoot\", (evt, root) => onDetachRoot(editor, evt, root));\n      viewDocument.on(\"focus\", event => {\n        /* istanbul ignore else -- @preserve */\n        if (props.onFocus) {\n          props.onFocus(event, editor);\n        }\n      });\n      viewDocument.on(\"blur\", event => {\n        /* istanbul ignore else -- @preserve */\n        if (props.onBlur) {\n          props.onBlur(event, editor);\n        }\n      });\n      return editor;\n    });\n  });\n  const _destroyEditor = initializeResult => {\n    const {\n      watchdog,\n      instance\n    } = initializeResult;\n    return new Promise((resolve, reject) => {\n      /* istanbul ignore next -- @preserve */\n      setTimeout(async () => {\n        try {\n          if (watchdog) {\n            await watchdog.destroy();\n            return resolve();\n          }\n          if (instance) {\n            await instance.destroy();\n            return resolve();\n          }\n          resolve();\n        } catch (e) {\n          console.error(e);\n          reject(e);\n        }\n      });\n    });\n  };\n  const _initializeEditor = async () => {\n    if (props.disableWatchdog) {\n      const instance = await _createEditor(props.data, _getConfig());\n      return {\n        instance,\n        watchdog: null\n      };\n    }\n    const watchdog = (() => {\n      if (isContextWatchdogReadyToUse(context)) {\n        return new EditorWatchdogAdapter(context.watchdog);\n      }\n      return new props.editor.EditorWatchdog(props.editor, props.watchdogConfig);\n    })();\n    const totalRestartsRef = {\n      current: 0\n    };\n    watchdog.setCreator(async (_, config) => {\n      const {\n        onAfterDestroy\n      } = props;\n      if (totalRestartsRef.current > 0 && onAfterDestroy && editorRefs.instance.current) {\n        onAfterDestroy(editorRefs.instance.current);\n      }\n      const instance = await _createEditor(data, config);\n      if (totalRestartsRef.current > 0) {\n        semaphore.unsafeSetValue({\n          instance,\n          watchdog\n        });\n        setTimeout(() => {\n          /* istanbul ignore next -- @preserve */\n          if (props.onReady) {\n            props.onReady(watchdog.editor);\n          }\n        });\n      }\n      totalRestartsRef.current++;\n      return instance;\n    });\n    watchdog.on(\"error\", (_, {\n      error,\n      causesRestart\n    }) => {\n      const onError = props.onError || console.error;\n      onError(error, {\n        phase: \"runtime\",\n        willEditorRestart: causesRestart\n      });\n    });\n    await watchdog.create(data, _getConfig()).catch(error => {\n      const onError = props.onError || console.error;\n      onError(error, {\n        phase: \"initialization\",\n        willEditorRestart: false\n      });\n      throw error;\n    });\n    return {\n      watchdog,\n      instance: watchdog.editor\n    };\n  };\n  const _getStateDiff = (previousState, newState) => {\n    const previousStateKeys = Object.keys(previousState);\n    const newStateKeys = Object.keys(newState);\n    return {\n      addedKeys: newStateKeys.filter(key => !previousStateKeys.includes(key)),\n      removedKeys: previousStateKeys.filter(key => !newStateKeys.includes(key))\n    };\n  };\n  const _externalSetData = useCallback(newData => {\n    semaphore.runAfterMount(() => {\n      shouldUpdateEditor.current = true;\n      setData(newData);\n    });\n  }, [setData]);\n  const _externalSetAttributes = useCallback(newAttributes => {\n    semaphore.runAfterMount(() => {\n      shouldUpdateEditor.current = true;\n      setAttributes(newAttributes);\n    });\n  }, [setAttributes]);\n  const toolbarElement = /* @__PURE__ */React.createElement(EditorToolbarWrapper, {\n    ref: semaphoreElementRef,\n    editor: editorRefs.instance.current\n  });\n  useInstantEditorEffect(semaphore.current, ({\n    instance\n  }) => {\n    if (props.disabled) {\n      instance.enableReadOnlyMode(REACT_INTEGRATION_READ_ONLY_LOCK_ID);\n    } else {\n      instance.disableReadOnlyMode(REACT_INTEGRATION_READ_ONLY_LOCK_ID);\n    }\n  }, [props.disabled]);\n  useInstantEditorEffect(semaphore.current, ({\n    instance\n  }) => {\n    if (shouldUpdateEditor.current) {\n      shouldUpdateEditor.current = false;\n      const dataKeys = Object.keys(data);\n      const attributesKeys = Object.keys(attributes);\n      if (!dataKeys.every(key => attributesKeys.includes(key))) {\n        console.error(\"`data` and `attributes` objects must have the same keys (roots).\");\n        throw new Error(\"`data` and `attributes` objects must have the same keys (roots).\");\n      }\n      const editorData = instance.getFullData();\n      const editorAttributes = instance.getRootsAttributes();\n      const {\n        addedKeys: newRoots,\n        removedKeys: removedRoots\n      } = _getStateDiff(editorData, data || /* istanbul ignore next -- @preserve: It should never happen, data should be always filled. */\n      {});\n      const modifiedRoots = dataKeys.filter(rootName => editorData[rootName] !== void 0 && JSON.stringify(editorData[rootName]) !== JSON.stringify(data[rootName]));\n      const rootsWithChangedAttributes = attributesKeys.filter(rootName => JSON.stringify(editorAttributes[rootName]) !== JSON.stringify(attributes[rootName]));\n      const _handleNewRoots = roots2 => {\n        roots2.forEach(rootName => {\n          instance.addRoot(rootName, {\n            data: data[rootName] || \"\",\n            attributes: (attributes == null ? void 0 : attributes[rootName]) || /* istanbul ignore next -- @preserve: attributes should be in sync with root keys */\n            {},\n            isUndoable: true\n          });\n        });\n      };\n      const _handleRemovedRoots = roots2 => {\n        roots2.forEach(rootName => {\n          instance.detachRoot(rootName, true);\n        });\n      };\n      const _updateEditorData = roots2 => {\n        const dataToUpdate = roots2.reduce((result, rootName) => ({\n          ...result,\n          [rootName]: data[rootName]\n        }), /* @__PURE__ */Object.create(null));\n        instance.data.set(dataToUpdate, {\n          suppressErrorInCollaboration: true\n        });\n      };\n      const _updateEditorAttributes = (writer, roots2) => {\n        roots2.forEach(rootName => {\n          Object.keys(attributes[rootName]).forEach(attr => {\n            instance.registerRootAttribute(attr);\n          });\n          writer.clearAttributes(instance.model.document.getRoot(rootName));\n          writer.setAttributes(attributes[rootName], instance.model.document.getRoot(rootName));\n        });\n      };\n      setTimeout(() => {\n        instance.model.change(writer => {\n          _handleNewRoots(newRoots);\n          _handleRemovedRoots(removedRoots);\n          if (modifiedRoots.length) {\n            _updateEditorData(modifiedRoots);\n          }\n          if (rootsWithChangedAttributes.length) {\n            _updateEditorAttributes(writer, rootsWithChangedAttributes);\n          }\n        });\n      });\n    }\n  }, [data, attributes]);\n  const editableElements = roots.map(rootName => /* @__PURE__ */React.createElement(EditorEditable, {\n    key: rootName,\n    id: rootName,\n    rootName,\n    semaphore\n  }));\n  return {\n    editor: editorRefs.instance.current,\n    editableElements,\n    toolbarElement,\n    data,\n    setData: _externalSetData,\n    attributes,\n    setAttributes: _externalSetAttributes\n  };\n};\nconst EditorEditable = memo(forwardRef(({\n  id,\n  semaphore,\n  rootName\n}, ref) => {\n  const innerRef = useRef(null);\n  useEffect(() => {\n    let editable;\n    let editor;\n    semaphore.runAfterMount(({\n      instance\n    }) => {\n      if (!innerRef.current) {\n        return;\n      }\n      editor = instance;\n      const {\n        ui,\n        model\n      } = editor;\n      const root = model.document.getRoot(rootName);\n      if (root && editor.ui.getEditableElement(rootName)) {\n        editor.detachEditable(root);\n      }\n      editable = ui.view.createEditable(rootName, innerRef.current);\n      ui.addEditable(editable);\n      instance.editing.view.forceRender();\n    });\n    return () => {\n      if (editor && editor.state !== \"destroyed\" && innerRef.current) {\n        const root = editor.model.document.getRoot(rootName);\n        /* istanbul ignore else -- @preserve */\n        if (root) {\n          editor.detachEditable(root);\n        }\n      }\n    };\n  }, [semaphore.revision]);\n  return /* @__PURE__ */React.createElement(\"div\", {\n    key: semaphore.revision,\n    id,\n    ref: mergeRefs(ref, innerRef)\n  });\n}));\nEditorEditable.displayName = \"EditorEditable\";\nconst EditorToolbarWrapper = forwardRef(({\n  editor\n}, ref) => {\n  const toolbarRef = useRef(null);\n  useEffect(() => {\n    const toolbarContainer = toolbarRef.current;\n    if (!editor || !toolbarContainer) {\n      return void 0;\n    }\n    const element = editor.ui.view.toolbar.element;\n    toolbarContainer.appendChild(element);\n    return () => {\n      if (toolbarContainer.contains(element)) {\n        toolbarContainer.removeChild(element);\n      }\n    };\n  }, [editor && editor.id]);\n  return /* @__PURE__ */React.createElement(\"div\", {\n    ref: mergeRefs(toolbarRef, ref)\n  });\n});\nEditorToolbarWrapper.displayName = \"EditorToolbarWrapper\";\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nconst useIsUnmountedRef = () => {\n  const mountedRef = useRef(false);\n  useEffect(() => {\n    mountedRef.current = false;\n    return () => {\n      mountedRef.current = true;\n    };\n  }, []);\n  return mountedRef;\n};\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nconst useAsyncCallback = callback => {\n  const [asyncState, setAsyncState] = useState({\n    status: \"idle\"\n  });\n  const unmountedRef = useIsUnmountedRef();\n  const prevExecutionUIDRef = useRef(null);\n  const asyncExecutor = useRefSafeCallback(async (...args) => {\n    if (unmountedRef.current || isSSR()) {\n      return null;\n    }\n    const currentExecutionUUID = uid();\n    prevExecutionUIDRef.current = currentExecutionUUID;\n    try {\n      if (asyncState.status !== \"loading\") {\n        setAsyncState({\n          status: \"loading\"\n        });\n      }\n      const result = await callback(...args);\n      if (!unmountedRef.current && prevExecutionUIDRef.current === currentExecutionUUID) {\n        setAsyncState({\n          status: \"success\",\n          data: result\n        });\n      }\n      return result;\n    } catch (error) {\n      console.error(error);\n      if (!unmountedRef.current && prevExecutionUIDRef.current === currentExecutionUUID) {\n        setAsyncState({\n          status: \"error\",\n          error\n        });\n      }\n    }\n    return null;\n  });\n  return [asyncExecutor, asyncState];\n};\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nconst useAsyncValue = (callback, deps) => {\n  const [asyncCallback, asyncState] = useAsyncCallback(callback);\n  useInstantEffect(asyncCallback, deps);\n  if (asyncState.status === \"idle\") {\n    return {\n      status: \"loading\"\n    };\n  }\n  return asyncState;\n};\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nfunction useCKEditorCloud(config) {\n  const serializedConfigKey = JSON.stringify(config);\n  const result = useAsyncValue(async () => loadCKEditorCloud(config), [serializedConfigKey]);\n  if (result.status === \"success\") {\n    return {\n      ...result.data,\n      status: \"success\"\n    };\n  }\n  return result;\n}\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nconst withCKEditorCloud = config => WrappedComponent => {\n  const ComponentWithCKEditorCloud = props => {\n    var _a, _b;\n    const ckeditorCloudResult = useCKEditorCloud(config.cloud);\n    switch (ckeditorCloudResult.status) {\n      case \"error\":\n        if (!config.renderError) {\n          return \"Unable to load CKEditor Cloud data!\";\n        }\n        return config.renderError(ckeditorCloudResult.error);\n      case \"success\":\n        return /* @__PURE__ */React.createElement(WrappedComponent, {\n          ...props,\n          cloud: ckeditorCloudResult\n        });\n      default:\n        return (_b = (_a = config.renderLoader) == null ? void 0 : _a.call(config)) != null ? _b : null;\n    }\n  };\n  ComponentWithCKEditorCloud.displayName = \"ComponentWithCKEditorCloud\";\n  return ComponentWithCKEditorCloud;\n};\nexport { CKEditor, CKEditorContext, loadCKEditorCloud2 as loadCKEditorCloud, useCKEditorCloud, useMultiRootEditor, withCKEditorCloud };","map":{"version":3,"names":["_LifeCycleElementSemaphore","constructor","element","lifecycle","__publicField","destroyedBeforeInitialization","mountingInProgress","once","_releaseLock","_state","_element","_lifecycle","then","unmount","mountResult","value","catch","error","console","resolve","_value","_lock","unsafeSetValue","_afterMountCallbacks","forEach","callback","runAfterMount","push","_semaphores","prevElementSemaphore","get","Promise","releaseLock","createDefer","newElementSemaphore","mount","afterMount","promise","delete","set","Map","LifeCycleElementSemaphore","ReactContextMetadataKey","withCKEditorReactContextMetadata","metadata","config","tryExtractCKEditorReactContextMetadata","object","useIsMountedRef","mountedRef","useRef","useEffect","current","useRefSafeCallback","fn","callbackRef","useCallback","args","useInitializedCKEditorsMap","currentContextWatchdog","onChangeInitializedEditors","onChangeInitializedEditorsSafe","status","watchdog","editors","_a","context","getInitializedContextEditors","reduce","map","editor","state","nameOrId","_a2","name","id","instance","Object","create","onEditorStatusChange","trackEditorLifecycle","priority","onAddEditorToCollection","_","on","Array","from","some","off","ContextWatchdogContext","React","createContext","CKEditorContext","props","watchdogConfig","children","onReady","contextWatchdog","ContextWatchdogConstructor","isLayoutReady","onError","details","isMountedRef","prevWatchdogInitializationIDRef","setCurrentContextWatchdog","useState","initializeContextWatchdog","destroy","regenerateInitializationID","uid","canUpdateState","initializationID","watchdogInitializationID","errorEvent","phase","willContextRestart","causesRestart","createElement","Provider","isContextWatchdogValue","obj","includes","isContextWatchdogValueWithStatus","isContextWatchdogInitializing","isContextWatchdogReadyToUse","ReactIntegrationUsageDataPlugin","createIntegrationUsageDataPlugin","version","frameworkVersion","appendAllIntegrationPluginsToConfig","editorConfig","isCKEditorFreeLicense","licenseKey","appendExtraPluginsToEditorConfig","REACT_INTEGRATION_READ_ONLY_LOCK_ID$1","CKEditor","Component","createRef","_checkVersion","CKEDITOR_VERSION","window","warn","major","split","Number","startsWith","_semaphoreValue","editorSemaphore","shouldComponentUpdate","nextProps","disableWatchdog","_shouldUpdateEditorData","data","disabled","enableReadOnlyMode","disableReadOnlyMode","componentDidMount","_initLifeCycleSemaphore","componentDidUpdate","componentWillUnmount","_unlockLifeCycleSemaphore","release","domContainer","_initializeEditor","onAfterDestroy","_destroyEditor","innerHTML","render","ref","_createEditor","_getConfig","EditorWatchdogAdapter","EditorWatchdog","totalRestartsRef","setCreator","el","setTimeout","willEditorRestart","contextItemMetadata","modelDocument","model","document","viewDocument","editing","view","event","onChange","onFocus","onBlur","initializeResult","reject","e","prevProps","initialData","_contextWatchdog","_id","creator","_creator","sourceElementOrData","add","type","_2","itemId","remove","getItem","useLifeCycleSemaphoreSyncRef","semaphoreRef","revision","setRevision","Date","now","refresh","rerender","replace","newSemaphore","createAttributeRef","key","mergeRefs","refs","useInstantEffect","deps","prevDeps","setDeps","shallowCompareArrays","useInstantEditorEffect","semaphore","REACT_INTEGRATION_READ_ONLY_LOCK_ID","useMultiRootEditor","semaphoreElementRef","semaphoreElement","editorRefs","useContext","roots","setRoots","keys","setData","attributes","setAttributes","rootsAttributes","shouldUpdateEditor","forceAssignFakeEditableElements","initializeEditableWithFakeElement","editable","getDomRoot","attachDomRoot","values","ui","editables","onChangeData","disableTwoWayDataBinding","newData","newAttributes","differ","getChanges","change","root","position","range","isAttached","rootName","getData","getChangedRoots","changedRoot","getRootAttributes","length","previousData","previousAttributes","onAddRoot","_evt","prevRoots","uniq","onDetachRoot","_editor","filter","root2","overwriteObject","overwriteArray","editorData","getFullData","getRootsAttributes","evt","_getStateDiff","previousState","newState","previousStateKeys","newStateKeys","addedKeys","removedKeys","_externalSetData","_externalSetAttributes","toolbarElement","EditorToolbarWrapper","dataKeys","attributesKeys","every","Error","editorAttributes","newRoots","removedRoots","modifiedRoots","JSON","stringify","rootsWithChangedAttributes","_handleNewRoots","roots2","addRoot","isUndoable","_handleRemovedRoots","detachRoot","_updateEditorData","dataToUpdate","result","suppressErrorInCollaboration","_updateEditorAttributes","writer","attr","registerRootAttribute","clearAttributes","getRoot","editableElements","EditorEditable","memo","forwardRef","innerRef","getEditableElement","detachEditable","createEditable","addEditable","forceRender","displayName","toolbarRef","toolbarContainer","toolbar","appendChild","contains","removeChild","useIsUnmountedRef","useAsyncCallback","asyncState","setAsyncState","unmountedRef","prevExecutionUIDRef","asyncExecutor","isSSR","currentExecutionUUID","useAsyncValue","asyncCallback","useCKEditorCloud","serializedConfigKey","loadCKEditorCloud","withCKEditorCloud","WrappedComponent","ComponentWithCKEditorCloud","ckeditorCloudResult","cloud","renderError","_b","renderLoader","call"],"sources":["C:\\Users\\vaish\\OneDrive\\Desktop\\Notes_world\\educational-website\\client\\node_modules\\@ckeditor\\ckeditor5-react\\src\\lifecycle\\LifeCycleElementSemaphore.ts","C:\\Users\\vaish\\OneDrive\\Desktop\\Notes_world\\educational-website\\client\\node_modules\\@ckeditor\\ckeditor5-react\\src\\context\\setCKEditorReactContextMetadata.ts","C:\\Users\\vaish\\OneDrive\\Desktop\\Notes_world\\educational-website\\client\\node_modules\\@ckeditor\\ckeditor5-react\\src\\hooks\\useIsMountedRef.ts","C:\\Users\\vaish\\OneDrive\\Desktop\\Notes_world\\educational-website\\client\\node_modules\\@ckeditor\\ckeditor5-react\\src\\hooks\\useRefSafeCallback.ts","C:\\Users\\vaish\\OneDrive\\Desktop\\Notes_world\\educational-website\\client\\node_modules\\@ckeditor\\ckeditor5-react\\src\\context\\useInitializedCKEditorsMap.ts","C:\\Users\\vaish\\OneDrive\\Desktop\\Notes_world\\educational-website\\client\\node_modules\\@ckeditor\\ckeditor5-react\\src\\context\\ckeditorcontext.tsx","C:\\Users\\vaish\\OneDrive\\Desktop\\Notes_world\\educational-website\\client\\node_modules\\@ckeditor\\ckeditor5-react\\src\\plugins\\ReactIntegrationUsageDataPlugin.ts","C:\\Users\\vaish\\OneDrive\\Desktop\\Notes_world\\educational-website\\client\\node_modules\\@ckeditor\\ckeditor5-react\\src\\plugins\\appendAllIntegrationPluginsToConfig.ts","C:\\Users\\vaish\\OneDrive\\Desktop\\Notes_world\\educational-website\\client\\node_modules\\@ckeditor\\ckeditor5-react\\src\\ckeditor.tsx","C:\\Users\\vaish\\OneDrive\\Desktop\\Notes_world\\educational-website\\client\\node_modules\\@ckeditor\\ckeditor5-react\\src\\lifecycle\\useLifeCycleSemaphoreSyncRef.tsx","C:\\Users\\vaish\\OneDrive\\Desktop\\Notes_world\\educational-website\\client\\node_modules\\@ckeditor\\ckeditor5-react\\src\\utils\\mergeRefs.ts","C:\\Users\\vaish\\OneDrive\\Desktop\\Notes_world\\educational-website\\client\\node_modules\\@ckeditor\\ckeditor5-react\\src\\hooks\\useInstantEffect.ts","C:\\Users\\vaish\\OneDrive\\Desktop\\Notes_world\\educational-website\\client\\node_modules\\@ckeditor\\ckeditor5-react\\src\\hooks\\useInstantEditorEffect.ts","C:\\Users\\vaish\\OneDrive\\Desktop\\Notes_world\\educational-website\\client\\node_modules\\@ckeditor\\ckeditor5-react\\src\\useMultiRootEditor.tsx","C:\\Users\\vaish\\OneDrive\\Desktop\\Notes_world\\educational-website\\client\\node_modules\\@ckeditor\\ckeditor5-react\\src\\hooks\\useIsUnmountedRef.ts","C:\\Users\\vaish\\OneDrive\\Desktop\\Notes_world\\educational-website\\client\\node_modules\\@ckeditor\\ckeditor5-react\\src\\hooks\\useAsyncCallback.ts","C:\\Users\\vaish\\OneDrive\\Desktop\\Notes_world\\educational-website\\client\\node_modules\\@ckeditor\\ckeditor5-react\\src\\hooks\\useAsyncValue.ts","C:\\Users\\vaish\\OneDrive\\Desktop\\Notes_world\\educational-website\\client\\node_modules\\@ckeditor\\ckeditor5-react\\src\\cloud\\useCKEditorCloud.tsx","C:\\Users\\vaish\\OneDrive\\Desktop\\Notes_world\\educational-website\\client\\node_modules\\@ckeditor\\ckeditor5-react\\src\\cloud\\withCKEditorCloud.tsx"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\n\nimport { createDefer, once, type Defer } from '@ckeditor/ckeditor5-integrations-common';\n\n/**\n * This class is utilized to pause the initialization of an editor when another instance is already present on a specified element.\n * It is engineered to address the following issues:\n *\n *\t* Rapid changes in component properties often lead to the re-initialization of the editor, which can trigger\n *\t  the `editor-source-element-already-used` exception. This occurs because the editor is still in the process of initializing\n *\t  when the component decides to destroy it. This semaphore waits for the editor to fully initialize before destroying it, thereby\n *\t  allowing a new instance of the editor to be attached to the specified element.\n *\n *\t* Rapid mounting and unmounting in strict mode frequently results in the `editor-source-element-already-used` exception\n *\t  being thrown by the editor. This is due to React reusing the underlying DOM element during the mounting and unmounting of components\n *\t  (especially if the same component is being mounted and unmounted). Consequently, a race condition arises. The first render begins to\n *\t  attach the editor (in async mode), and shortly thereafter, it is destroyed and a new instance of the component is initialized.\n *\t  This semaphore, by utilizing a static semaphores promises map, retains information about whether the element is used by a previous\n *\t  instance of the editor and resumes execution when it is freed.\n *\n *\t* The process involves starting up many editors that are no longer needed and are immediately removed in the following rerenders.\n *\t  This can cause the editor’s initialization performance to slow down. The initialization of the editor is skipped when numerous\n *\t  rerenders occur within a short time-frame while using this semaphore. An example of this could be a situation with 4 rerenders\n *\t  occurring within a 10ms period. This semaphore will likely batch these calls, and instead of initializing 4 editors, only 2 will be\n *\t  initialized (the first and the last one).\n */\nexport class LifeCycleElementSemaphore<R> {\n\t/**\n\t * This is a map of elements associated with promises. It informs the semaphore that the underlying HTML element, used as a key,\n\t * is currently in use by another editor. Each element is assigned a promise, which allows for the easy chaining of new\n\t * editor instances on an element that is already in use by another instance. The process works as follows:\n\t *\n\t * \t1. If an element is being used by an editor, then the initialization of a new editor\n\t * \t   instance is chained using the `.then()` method of the Promise.\n\t *\n\t * \t2. If the editor associated with the underlying element is destroyed, then `Promise.resolve()` is called\n\t * \t   and the previously assigned `.then()` editor callback is executed.\n\t *\n\t *  @see {@link #lock} for more detailed information on the implementation.\n\t */\n\tprivate static readonly _semaphores = new Map<HTMLElement, Promise<void>>();\n\n\t/**\n\t * This should define async methods for initializing and destroying the editor.\n\t * Essentially, it's an async version of basic React lifecycle methods like `componentDidMount`, `componentWillUnmount`.\n\t *\n\t * \t* Result of {@link LifeCycleAsyncOperators#mount} method is passed to {@link LifeCycleAsyncOperators#unmount} as an argument.\n\t */\n\tprivate readonly _lifecycle: LifeCycleAsyncOperators<R>;\n\n\t/**\n\t * This is the element instance that the editor uses for mounting. This element should contain the `ckeditorInstance` member\n\t * once the editor has been successfully mounted to it. The semaphore ensures that a new instance of the editor, which will\n\t * be assigned to this element by the {@link #_lifecycle:mount} method, will always be initialized after the successful\n\t * destruction of the underlying `ckeditorInstance` that was previously mounted on this element.\n\t */\n\tprivate readonly _element: HTMLElement;\n\n\t/**\n\t * This is the lock mechanism utilized by the {@link #lock} and {@link #release} methods.\n\t *\n\t * \t* If the editor is not yet mounted and is awaiting mounting (for instance, when another editor is\n\t * \t  occupying the element), then it is null.\n\t *\n\t * \t* When the editor is mounted on the element, this variable holds an unresolved promise that will be\n\t * \t  resolved after the editor is destroyed.\n\t *\n\t * \t* Once the editor is destroyed (and it was previously mounted), the promise is resolved.\n\t */\n\tprivate _releaseLock: Defer<void> | null = null;\n\n\t/**\n\t * This is the result of the {@link #_lifecycle:mount} function. This value should be reset to `null`\n\t * once the semaphore is released. It is utilized to store certain data that must be removed following\n\t * the destruction of the editor. This data may include the editor's instance, the assigned watchdog,\n\t * or handles for additional window listeners.\n\t */\n\tprivate _value: R | null = null;\n\n\t/**\n\t * This is a list of callbacks that are triggered if the semaphore {@link #_lifecycle:mount} method executes successfully.\n\t * It is utilized in scenarios where we need to assign certain properties to an editor that is currently in the process of mounting.\n\t * An instance of such usage could be two-way binding. We aim to prevent the loss of all `setData` calls if the editor has not\n\t * yet been mounted, therefore these calls will be executed immediately following the completion of the mounting process.\n\t */\n\tprivate _afterMountCallbacks: Array<LifeCycleAfterMountCallback<R>> = [];\n\n\t/**\n\t * This represents the actual mounting state of the semaphore. It is primarily used by the {@link #release} method to\n\t * determine whether the initialization of the editor should be skipped or, if the editor is already initialized, the editor\n\t * should be destroyed.\n\t *\n\t * \t* If `destroyedBeforeInitialization` is true, then the {@link #release} method was invoked before the editor began to mount.\n\t * \t  This often occurs in strict mode when we assign a promise to the {@link LifeCycleEditorElementSemaphore#_semaphores} map\n\t * \t  and the assigned `mount` callback has not yet been called. In this scenario, it is safe to skip the initialization of the editor\n\t * \t  and simply release the semaphore.\n\t *\n\t *\t* If `mountingInProgress` is a Promise, then the {@link #release} method was invoked after the initialization of the editor and\n\t \t  the editor must be destroyed before the semaphore is released.\n\t*/\n\tprivate _state: LifeCycleState<R> = {\n\t\tdestroyedBeforeInitialization: false,\n\t\tmountingInProgress: null\n\t};\n\n\tconstructor( element: HTMLElement, lifecycle: LifeCycleAsyncOperators<R> ) {\n\t\tthis._element = element;\n\t\tthis._lifecycle = lifecycle;\n\t\tthis._lock();\n\t}\n\n\t/**\n\t * Getter for {@link #_value}.\n\t */\n\tpublic get value(): R | null {\n\t\treturn this._value;\n\t}\n\n\t/**\n\t * Occasionally, the Watchdog restarts the editor instance, resulting in a new instance being assigned to the semaphore.\n\t * In terms of race conditions, it's generally safer to simply override the semaphore value rather than recreating it\n\t * with a different one.\n\t */\n\tpublic unsafeSetValue( value: R ): void {\n\t\tthis._value = value;\n\n\t\tthis._afterMountCallbacks.forEach( callback => callback( value ) );\n\t\tthis._afterMountCallbacks = [];\n\t}\n\n\t/**\n\t * This registers a callback that will be triggered after the editor has been successfully mounted.\n\t *\n\t * \t* If the editor is already mounted, the callback will be executed immediately.\n\t *\t* If the editor is in the process of mounting, the callback will be executed upon successful mounting.\n\t* \t* If the editor is never mounted, the passed callback will not be executed.\n\t* \t* If an exception is thrown within the callback, it will be re-thrown in the semaphore.\n\t*/\n\tpublic runAfterMount( callback: LifeCycleAfterMountCallback<R> ): void {\n\t\tconst { _value, _afterMountCallbacks } = this;\n\n\t\tif ( _value ) {\n\t\t\tcallback( _value );\n\t\t} else {\n\t\t\t_afterMountCallbacks.push( callback );\n\t\t}\n\t}\n\n\t/**\n\t * This method is used to inform other components that the {@link #_element} will be used by the editor,\n\t * which is initialized by the {@link #_lifecycle} methods.\n\t *\n\t * \t* If an editor is already present on the provided element, the initialization of the current one\n\t * \t  will be postponed until the previous one is destroyed.\n\t *\n\t * \t* If the element is empty and does not have an editor attached to it, the currently locked editor will\n\t * \t  be mounted immediately.\n\t *\n\t * After the successful initialization of the editor and the assignment of the {@link #_value} member,\n\t * the `onReady` lifecycle method is called.\n\t *\n\t * *Important note:*\n\t *\n\t * It’s really important to keep this method *sync*. If we make this method *async*, it won’t work well because\n\t * it will cause problems when we’re trying to set up the {@link LifeCycleEditorElementSemaphore#_semaphores} map entries.\n\t */\n\tprivate _lock(): void {\n\t\tconst { _semaphores } = LifeCycleElementSemaphore;\n\t\tconst { _state, _element, _lifecycle } = this;\n\n\t\t// This promise signifies that the previous editor is still attached to the current element.\n\t\t// Upon successful resolution, it will indicate that it is safe to assume that the element has\n\t\t// no assigned editor instance and can be reinitialized.\n\t\tconst prevElementSemaphore = _semaphores.get( _element ) || Promise.resolve( null );\n\n\t\t// This is a lock that will be resolved after the `release` method is called. Due to this lock,\n\t\t// the promise will never be resolved until the editor is destroyed.\n\t\tconst releaseLock = createDefer();\n\t\tthis._releaseLock = releaseLock;\n\n\t\t// This is the initialization of the editor that occurs after the previous editor has been detached from the specified element.\n\t\t//\n\t\t// If the `release` method was called before the initialization of the current editor instance, then it will be skipped.\n\t\t// This situation occurs quite frequently when we have three or more rerenders in a row, and it doesn't make sense to initialize\n\t\t// the second editor because it will be overridden anyway by the third one.\n\t\tconst newElementSemaphore = prevElementSemaphore\n\t\t\t.then( () => {\n\t\t\t\tif ( _state.destroyedBeforeInitialization ) {\n\t\t\t\t\treturn Promise.resolve( undefined );\n\t\t\t\t}\n\n\t\t\t\t// This variable will be used later in the `release` method to determine\n\t\t\t\t// whether the editor is being destroyed prior to initialization.\n\t\t\t\t_state.mountingInProgress = _lifecycle.mount().then( mountResult => {\n\t\t\t\t\tif ( mountResult ) {\n\t\t\t\t\t\tthis.unsafeSetValue( mountResult );\n\t\t\t\t\t}\n\n\t\t\t\t\treturn mountResult;\n\t\t\t\t} );\n\n\t\t\t\treturn _state.mountingInProgress;\n\t\t\t} )\n\t\t\t.then( async mountResult => {\n\t\t\t\t// Everything is fine, all ready callback might be fired here.\n\t\t\t\tif ( mountResult && _lifecycle.afterMount ) {\n\t\t\t\t\tawait _lifecycle.afterMount( {\n\t\t\t\t\t\telement: _element,\n\t\t\t\t\t\tmountResult\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t} )\n\n\t\t\t// It will be released after destroying of editor by the {@link #_release method}.\n\t\t\t.then( () => releaseLock.promise )\n\n\t\t\t// Prevent hanging of semaphore during mount, just assume that everything is fine\n\t\t\t.catch( error => {\n\t\t\t\tconsole.error( 'Semaphore mounting error:', error );\n\t\t\t} )\n\n\t\t\t// Remove semaphore from map if released.\n\t\t\t.then( () => {\n\t\t\t\tif ( _semaphores.get( _element ) === newElementSemaphore ) {\n\t\t\t\t\t_semaphores.delete( _element );\n\t\t\t\t}\n\t\t\t} );\n\n\t\t_semaphores.set( _element, newElementSemaphore );\n\t}\n\n\t/**\n\t * Inverse of {@link #_lock} method that tries to destroy attached editor.\n\t *\n\t * \t* If editor is being already attached to element (or is in attaching process) then after fully initialization of editor\n\t * \t  destroy is performed and semaphore is released. The {@link #_lifecycle} unmount method is called.\n\t *\n\t * \t* If editor is being destroyed before initialization then it does nothing but sets `destroyedBeforeInitialization` flag that\n\t * \t  will be later checked by {@link #_lock} method in initialization. The {@link #_lifecycle} unmount method is not called.\n\t *\n\t * *Important note:*\n\t *\n\t * It’s really important to keep this method *sync*. If we make this method *async*, it won’t work well because\n\t * it will cause problems when we’re trying to set up the {@link LifeCycleEditorElementSemaphore#_semaphores} map entries.\n\t */\n\tpublic readonly release = once( () => {\n\t\tconst { _releaseLock, _state, _element, _lifecycle } = this;\n\n\t\tif ( _state.mountingInProgress ) {\n\t\t\t_state.mountingInProgress\n\t\t\t\t.then( () => _lifecycle.unmount( {\n\t\t\t\t\telement: _element,\n\n\t\t\t\t\t// Mount result might be overridden by watchdog during restart so use instance variable.\n\t\t\t\t\tmountResult: this.value!\n\t\t\t\t} ) )\n\n\t\t\t\t// Prevent hanging of semaphore during unmount, just assume that everything is fine\n\t\t\t\t.catch( error => {\n\t\t\t\t\tconsole.error( 'Semaphore unmounting error:', error );\n\t\t\t\t} )\n\n\t\t\t\t.then( _releaseLock!.resolve )\n\t\t\t\t.then( () => {\n\t\t\t\t\tthis._value = null;\n\t\t\t\t} );\n\t\t} else {\n\t\t\t_state.destroyedBeforeInitialization = true;\n\t\t\t_releaseLock!.resolve();\n\t\t}\n\t} );\n}\n\nexport type LifeCycleAfterMountCallback<R> = ( mountResult: R ) => void;\n\ntype LifeCycleState<R> = {\n\tdestroyedBeforeInitialization: boolean;\n\tmountingInProgress: Promise<R> | null;\n};\n\ntype LifeCyclePostMountAttrs<R> = {\n\telement: HTMLElement;\n\tmountResult: R;\n};\n\nexport type LifeCycleAsyncOperators<R> = {\n\tmount: () => Promise<R>;\n\tafterMount?: ( result: LifeCyclePostMountAttrs<R> ) => Promise<void> | void;\n\tunmount: ( result: LifeCyclePostMountAttrs<R> ) => Promise<void>;\n};\n","/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\n\nimport type { Config, EditorConfig } from 'ckeditor5';\n\n/**\n * The symbol cannot be used as a key because config getters require strings as keys.\n */\nconst ReactContextMetadataKey = '$__CKEditorReactContextMetadata';\n\n/**\n * Sets the metadata in the object.\n *\n * @param metadata The metadata to set.\n * @param object The object to set the metadata in.\n * @returns The object with the metadata set.\n */\nexport function withCKEditorReactContextMetadata(\n\tmetadata: CKEditorConfigContextMetadata,\n\tconfig: EditorConfig\n): EditorConfig & { [ ReactContextMetadataKey ]: CKEditorConfigContextMetadata } {\n\treturn {\n\t\t...config,\n\t\t[ ReactContextMetadataKey ]: metadata\n\t};\n}\n\n/**\n * Tries to extract the metadata from the object.\n *\n * @param object The object to extract the metadata from.\n */\nexport function tryExtractCKEditorReactContextMetadata( object: Config<any> ): CKEditorConfigContextMetadata | null {\n\treturn object.get( ReactContextMetadataKey );\n}\n\n/**\n * The metadata that is stored in the React context.\n */\nexport type CKEditorConfigContextMetadata = {\n\n\t/**\n\t * The name of the editor in the React context. It'll be later used in the `useInitializedCKEditorsMap` hook\n\t * to track the editor initialization and destruction events.\n\t */\n\tname?: string;\n\n\t/**\n\t * Any additional metadata that can be stored in the context.\n\t */\n\t[x: string | number | symbol]: unknown;\n};\n","/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\n\nimport { useEffect, useRef, type MutableRefObject } from 'react';\n\n/**\n * Custom hook that returns a mutable ref object indicating whether the component is mounted or not.\n *\n * @returns The mutable ref object.\n */\nexport const useIsMountedRef = (): MutableRefObject<boolean> => {\n\tconst mountedRef = useRef<boolean>( false );\n\n\tuseEffect( () => {\n\t\tmountedRef.current = true;\n\n\t\treturn () => {\n\t\t\tmountedRef.current = false;\n\t\t};\n\t}, [] );\n\n\treturn mountedRef;\n};\n","/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\n\nimport { useCallback, useRef } from 'react';\n\n/**\n * Hook that guarantees that returns constant reference for passed function.\n * Useful for preventing closures from capturing cached scope variables (avoiding the stale closure problem).\n */\nexport const useRefSafeCallback = <A extends Array<unknown>, R>( fn: ( ...args: A ) => R ): typeof fn => {\n\tconst callbackRef = useRef<typeof fn>();\n\tcallbackRef.current = fn;\n\n\treturn useCallback(\n\t\t( ...args: A ): R => ( callbackRef.current as typeof fn )( ...args ),\n\t\t[]\n\t);\n};\n","/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\n\nimport { useEffect } from 'react';\nimport { useRefSafeCallback } from '../hooks/useRefSafeCallback.js';\n\nimport type { CollectionAddEvent, Context, ContextWatchdog, Editor, GetCallback } from 'ckeditor5';\nimport type { ContextWatchdogValue } from './ckeditorcontext.js';\n\nimport {\n\ttryExtractCKEditorReactContextMetadata,\n\ttype CKEditorConfigContextMetadata\n} from './setCKEditorReactContextMetadata.js';\n\n/**\n * A hook that listens for the editor initialization and destruction events and updates the editors map.\n *\n * @param config The configuration of the hook.\n * @param config.currentContextWatchdog The current context watchdog value.\n * @param config.onChangeInitializedEditors The function that updates the editors map.\n * @example\n * ```ts\n * useInitializedCKEditorsMap( {\n * \tcurrentContextWatchdog,\n * \tonChangeInitializedEditors: ( editors, context ) => {\n * \t\tconsole.log( 'Editors:', editors );\n * \t}\n * } );\n * ```\n */\nexport const useInitializedCKEditorsMap = <TContext extends Context>(\n\t{\n\t\tcurrentContextWatchdog,\n\t\tonChangeInitializedEditors\n\t}: InitializedContextEditorsConfig<TContext>\n): void => {\n\t// We need to use the safe callback to prevent the stale closure problem.\n\tconst onChangeInitializedEditorsSafe = useRefSafeCallback( onChangeInitializedEditors || ( () => {} ) );\n\n\tuseEffect( () => {\n\t\tif ( currentContextWatchdog.status !== 'initialized' ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst { watchdog } = currentContextWatchdog;\n\t\tconst editors = watchdog?.context?.editors;\n\n\t\tif ( !editors ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Get the initialized editors from\n\t\tconst getInitializedContextEditors = () => [ ...editors ].reduce<InitializedEditorsMap>(\n\t\t\t( map, editor ) => {\n\t\t\t\tif ( editor.state !== 'ready' ) {\n\t\t\t\t\treturn map;\n\t\t\t\t}\n\n\t\t\t\tconst metadata = tryExtractCKEditorReactContextMetadata( editor.config );\n\t\t\t\tconst nameOrId = metadata?.name ?? editor.id;\n\n\t\t\t\tmap[ nameOrId ] = {\n\t\t\t\t\tinstance: editor,\n\t\t\t\t\tmetadata\n\t\t\t\t};\n\n\t\t\t\treturn map;\n\t\t\t},\n\t\t\tObject.create( {} ) // Prevent the prototype pollution.\n\t\t);\n\n\t\t// The function that is called when the editor status changes.\n\t\tconst onEditorStatusChange = () => {\n\t\t\tonChangeInitializedEditorsSafe(\n\t\t\t\tgetInitializedContextEditors(),\n\t\t\t\twatchdog\n\t\t\t);\n\t\t};\n\n\t\t// Add the existing editors to the map.\n\t\tconst trackEditorLifecycle = ( editor: Editor ) => {\n\t\t\teditor.once( 'ready', onEditorStatusChange, { priority: 'lowest' } );\n\t\t\teditor.once( 'destroy', onEditorStatusChange, { priority: 'lowest' } );\n\t\t};\n\n\t\tconst onAddEditorToCollection: GetCallback<CollectionAddEvent<Editor>> = ( _, editor ) => {\n\t\t\ttrackEditorLifecycle( editor );\n\t\t};\n\n\t\teditors.forEach( trackEditorLifecycle );\n\t\teditors.on<CollectionAddEvent<Editor>>( 'add', onAddEditorToCollection );\n\n\t\t// Fire the initial change event if there is at least one editor ready, otherwise wait for the first ready editor.\n\t\tif ( Array.from( editors ).some( editor => editor.state === 'ready' ) ) {\n\t\t\tonEditorStatusChange();\n\t\t}\n\n\t\treturn () => {\n\t\t\teditors.off( 'add', onAddEditorToCollection );\n\t\t};\n\t}, [ currentContextWatchdog ] );\n};\n\n/**\n * A map of initialized editors.\n */\ntype InitializedEditorsMap = Record<string, {\n\tinstance: Editor;\n\tmetadata: CKEditorConfigContextMetadata | null;\n}>;\n\n/**\n * The configuration of the `useInitializedCKEditorsMap` hook.\n */\nexport type InitializedContextEditorsConfig<TContext extends Context> = {\n\n\t/**\n\t * The current context watchdog value.\n\t */\n\tcurrentContextWatchdog: ContextWatchdogValue<TContext>;\n\n\t/**\n\t * The callback called when the editors map changes.\n\t */\n\tonChangeInitializedEditors?: (\n\t\teditors: InitializedEditorsMap,\n\t\twatchdog: ContextWatchdog<TContext>\n\t) => void;\n};\n","/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\n\nimport React, {\n\tuseRef, useContext, useState, useEffect,\n\ttype PropsWithChildren,\n\ttype ReactElement\n} from 'react';\n\nimport { uid } from '@ckeditor/ckeditor5-integrations-common';\nimport { useIsMountedRef } from '../hooks/useIsMountedRef.js';\nimport {\n\tuseInitializedCKEditorsMap,\n\ttype InitializedContextEditorsConfig\n} from './useInitializedCKEditorsMap.js';\n\nimport type {\n\tContextWatchdog,\n\tWatchdogConfig,\n\tContext,\n\tContextConfig\n} from 'ckeditor5';\n\nexport const ContextWatchdogContext = React.createContext<ContextWatchdogValue | null>( null );\n\n/**\n * Custom hook that returns the CKEditor Watchdog context value.\n */\nexport const useCKEditorWatchdogContext = (): ContextWatchdogValue | null =>\n\tuseContext( ContextWatchdogContext );\n\n/**\n * A React component that provides a context for CKEditor.\n */\nconst CKEditorContext = <TContext extends Context = Context>( props: Props<TContext> ): ReactElement | null => {\n\tconst {\n\t\tid, context, watchdogConfig,\n\t\tchildren, config, onReady,\n\t\tcontextWatchdog: ContextWatchdogConstructor,\n\t\tisLayoutReady = true,\n\t\tonChangeInitializedEditors,\n\t\tonError = ( error, details ) => console.error( error, details )\n\t} = props;\n\n\tconst isMountedRef = useIsMountedRef();\n\tconst prevWatchdogInitializationIDRef = useRef<string | null>( null );\n\n\t// The currentContextWatchdog state is set to 'initializing' because it is checked later in the CKEditor component\n\t// which is waiting for the full initialization of the context watchdog.\n\tconst [ currentContextWatchdog, setCurrentContextWatchdog ] = useState<ContextWatchdogValue<TContext>>( {\n\t\tstatus: 'initializing'\n\t} );\n\n\t// Lets initialize the context watchdog when the layout is ready.\n\tuseEffect( () => {\n\t\tif ( isLayoutReady ) {\n\t\t\tinitializeContextWatchdog();\n\t\t} else {\n\t\t\tsetCurrentContextWatchdog( {\n\t\t\t\tstatus: 'initializing'\n\t\t\t} );\n\t\t}\n\t}, [ id, isLayoutReady ] );\n\n\t// Cleanup the context watchdog when the component is unmounted. Abort if the watchdog is not initialized.\n\tuseEffect( () => () => {\n\t\tif ( currentContextWatchdog.status === 'initialized' ) {\n\t\t\tcurrentContextWatchdog.watchdog.destroy();\n\t\t}\n\t}, [ currentContextWatchdog ] );\n\n\t// Listen for the editor initialization and destruction events and call the onChangeInitializedEditors function.\n\tuseInitializedCKEditorsMap( {\n\t\tcurrentContextWatchdog,\n\t\tonChangeInitializedEditors\n\t} );\n\n\t/**\n\t * Regenerates the initialization ID by generating a random ID and updating the previous watchdog initialization ID.\n\t * This is necessary to ensure that the state update is performed only if the current initialization ID matches the previous one.\n\t * This helps to avoid race conditions and ensures that the correct context watchdog is associated with the component.\n\t *\n\t * @returns The regenerated initialization ID.\n\t */\n\tfunction regenerateInitializationID() {\n\t\tprevWatchdogInitializationIDRef.current = uid();\n\n\t\treturn prevWatchdogInitializationIDRef.current;\n\t}\n\n\t/**\n\t * Checks if the state can be updated based on the provided initialization ID.\n\t *\n\t * @param initializationID The initialization ID to compare with the previous one.\n\t * @returns A boolean indicating whether the state can be updated.\n\t */\n\tfunction canUpdateState( initializationID: string ) {\n\t\treturn prevWatchdogInitializationIDRef.current === initializationID && isMountedRef.current;\n\t}\n\n\t/**\n\t * Initializes the context watchdog.\n\t *\n\t * @returns Watchdog instance.\n\t */\n\tfunction initializeContextWatchdog() {\n\t\t// The prevWatchdogInitializationID variable is used to keep track of the previous initialization ID.\n\t\t// It is used to ensure that the state update is performed only if the current initialization ID matches the previous one.\n\t\t// This helps to avoid race conditions and ensures that the correct context watchdog is associated with the component.\n\t\tconst watchdogInitializationID = regenerateInitializationID()!;\n\t\tconst contextWatchdog = new ContextWatchdogConstructor( context!, watchdogConfig );\n\n\t\t// Handle error event from context watchdog.\n\t\tcontextWatchdog.on( 'error', ( _, errorEvent ) => {\n\t\t\t/* istanbul ignore else -- @preserve */\n\t\t\tif ( canUpdateState( watchdogInitializationID ) ) {\n\t\t\t\tonError( errorEvent.error, {\n\t\t\t\t\tphase: 'runtime',\n\t\t\t\t\twillContextRestart: errorEvent.causesRestart\n\t\t\t\t} );\n\t\t\t}\n\t\t} );\n\n\t\t// Handle state change event from context watchdog.\n\t\tcontextWatchdog.on( 'stateChange', () => {\n\t\t\tif ( onReady && contextWatchdog.state === 'ready' && canUpdateState( watchdogInitializationID ) ) {\n\t\t\t\tonReady(\n\t\t\t\t\tcontextWatchdog.context! as TContext,\n\t\t\t\t\tcontextWatchdog\n\t\t\t\t);\n\t\t\t}\n\t\t} );\n\n\t\t// Create the context watchdog and initialize it with the provided config.\n\t\tcontextWatchdog\n\t\t\t.create( config )\n\t\t\t.then( () => {\n\t\t\t\t// Check if the state update is still valid and update the current context watchdog.\n\t\t\t\tif ( canUpdateState( watchdogInitializationID ) ) {\n\t\t\t\t\tsetCurrentContextWatchdog( {\n\t\t\t\t\t\tstatus: 'initialized',\n\t\t\t\t\t\twatchdog: contextWatchdog\n\t\t\t\t\t} );\n\t\t\t\t} else {\n\t\t\t\t\t// Destroy the context watchdog if the state update is no longer valid.\n\t\t\t\t\tcontextWatchdog.destroy();\n\t\t\t\t}\n\t\t\t} )\n\t\t\t.catch( error => {\n\t\t\t\t// Update the current context watchdog with the error status.\n\t\t\t\tif ( canUpdateState( watchdogInitializationID ) ) {\n\t\t\t\t\t// Handle error during context watchdog initialization.\n\t\t\t\t\tonError( error, {\n\t\t\t\t\t\tphase: 'initialization',\n\t\t\t\t\t\twillContextRestart: false\n\t\t\t\t\t} );\n\n\t\t\t\t\tsetCurrentContextWatchdog( {\n\t\t\t\t\t\tstatus: 'error',\n\t\t\t\t\t\terror\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t} );\n\n\t\treturn contextWatchdog;\n\t}\n\n\treturn (\n\t\t<ContextWatchdogContext.Provider value={currentContextWatchdog}>\n\t\t\t{children}\n\t\t</ContextWatchdogContext.Provider>\n\t);\n};\n\n/**\n * Checks if the given object is of type ContextWatchdogValue.\n *\n * @param obj The object to be checked.\n * @returns True if the object is of type ContextWatchdogValue, false otherwise.\n */\nexport const isContextWatchdogValue = ( obj: any ): obj is ContextWatchdogValue =>\n\t!!obj && typeof obj === 'object' && 'status' in obj && [ 'initializing', 'initialized', 'error' ].includes( obj.status );\n\n/**\n * Checks if the provided object is a context watchdog value with the specified status.\n */\nexport const isContextWatchdogValueWithStatus = <S extends ContextWatchdogValueStatus>( status: S ) =>\n\t( obj: any ): obj is ExtractContextWatchdogValueByStatus<S> =>\n\t\tisContextWatchdogValue( obj ) && obj.status === status;\n\n/**\n * Checks if the context watchdog is currently initializing.\n */\nexport const isContextWatchdogInitializing = isContextWatchdogValueWithStatus( 'initializing' );\n\n/**\n * Checks if the provided object is a fully initialized context watchdog value. It prevents race conditions between\n * watchdog state that is not fully synchronized with the context state. For example, the watchdog state can be 'destroyed'\n * while the context is still being initialized because context setState is pending.\n */\nexport const isContextWatchdogReadyToUse = ( obj: any ): obj is ExtractContextWatchdogValueByStatus<'initialized'> => (\n\tisContextWatchdogValueWithStatus( 'initialized' )( obj ) &&\n\tobj.watchdog.state === 'ready'\n);\n\n/**\n * Represents the value of the ContextWatchdog in the CKEditor context.\n */\nexport type ContextWatchdogValue<TContext extends Context = Context> =\n\t| {\n\t\tstatus: 'initializing';\n\t}\n\t| {\n\t\tstatus: 'initialized';\n\t\twatchdog: ContextWatchdog<TContext>;\n\t}\n\t| {\n\t\tstatus: 'error';\n\t\terror: ErrorDetails;\n\t};\n\n/**\n * Represents the status of the ContextWatchdogValue.\n */\nexport type ContextWatchdogValueStatus = ContextWatchdogValue[ 'status' ];\n\n/**\n * Extracts a specific type of `ContextWatchdogValue` based on its status.\n */\nexport type ExtractContextWatchdogValueByStatus<S extends ContextWatchdogValueStatus> = Extract<\n\tContextWatchdogValue,\n\t{ status: S }\n>;\n\n/**\n * Props for the CKEditorContext component.\n */\nexport type Props<TContext extends Context> =\n\t& PropsWithChildren\n\t& Pick<InitializedContextEditorsConfig<TContext>, 'onChangeInitializedEditors'>\n\t& {\n\t\tid?: string;\n\t\tisLayoutReady?: boolean;\n\t\tcontext?: { create( ...args: any ): Promise<TContext> };\n\t\tcontextWatchdog: typeof ContextWatchdog<TContext>;\n\t\twatchdogConfig?: WatchdogConfig;\n\t\tconfig?: ContextConfig;\n\t\tonReady?: ( context: TContext, watchdog: ContextWatchdog<TContext> ) => void;\n\t\tonError?: ( error: Error, details: ErrorDetails ) => void;\n\t};\n\ntype ErrorDetails = {\n\tphase: 'initialization' | 'runtime';\n\twillContextRestart: boolean;\n};\n\nexport default CKEditorContext;\n","/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\n\nimport React from 'react';\nimport { createIntegrationUsageDataPlugin } from '@ckeditor/ckeditor5-integrations-common';\n\n/**\n * This part of the code is not executed in open-source implementations using a GPL key.\n * It only runs when a specific license key is provided. If you are uncertain whether\n * this applies to your installation, please contact our support team.\n */\nexport const ReactIntegrationUsageDataPlugin = createIntegrationUsageDataPlugin(\n\t'react',\n\t{\n\t\tversion: __REACT_INTEGRATION_VERSION__,\n\t\tframeworkVersion: React.version\n\t}\n);\n","/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\n\nimport { appendExtraPluginsToEditorConfig, isCKEditorFreeLicense } from '@ckeditor/ckeditor5-integrations-common';\nimport type { EditorConfig } from 'ckeditor5';\n\nimport { ReactIntegrationUsageDataPlugin } from './ReactIntegrationUsageDataPlugin.js';\n\n/**\n * Appends all integration plugins to the editor configuration.\n *\n * @param editorConfig The editor configuration.\n * @returns The editor configuration with all integration plugins appended.\n */\nexport function appendAllIntegrationPluginsToConfig( editorConfig: EditorConfig ): EditorConfig {\n\t/**\n\t * Do not modify the editor configuration if the editor is using a free license.\n\t */\n\tif ( isCKEditorFreeLicense( editorConfig.licenseKey ) ) {\n\t\treturn editorConfig;\n\t}\n\n\treturn appendExtraPluginsToEditorConfig( editorConfig, [\n\t\t/**\n\t\t * This part of the code is not executed in open-source implementations using a GPL key.\n\t\t * It only runs when a specific license key is provided. If you are uncertain whether\n\t\t * this applies to your installation, please contact our support team.\n\t\t */\n\t\tReactIntegrationUsageDataPlugin\n\t] );\n}\n","/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\n\n/* globals window */\n\nimport React from 'react';\n\nimport type {\n\tEventInfo,\n\tEditor,\n\tEditorConfig,\n\tDocumentChangeEvent,\n\tEditorWatchdog,\n\tContextWatchdog,\n\tWatchdogConfig,\n\tEditorCreatorFunction\n} from 'ckeditor5';\n\nimport type { EditorSemaphoreMountResult } from './lifecycle/LifeCycleEditorSemaphore.js';\n\nimport { uid } from '@ckeditor/ckeditor5-integrations-common';\nimport { LifeCycleElementSemaphore } from './lifecycle/LifeCycleElementSemaphore.js';\n\nimport {\n\twithCKEditorReactContextMetadata,\n\ttype CKEditorConfigContextMetadata\n} from './context/setCKEditorReactContextMetadata.js';\n\nimport {\n\tContextWatchdogContext,\n\tisContextWatchdogInitializing,\n\tisContextWatchdogReadyToUse\n} from './context/ckeditorcontext.js';\n\nimport { appendAllIntegrationPluginsToConfig } from './plugins/appendAllIntegrationPluginsToConfig.js';\n\nconst REACT_INTEGRATION_READ_ONLY_LOCK_ID = 'Lock from React integration (@ckeditor/ckeditor5-react)';\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport default class CKEditor<TEditor extends Editor> extends React.Component<Props<TEditor>> {\n\t/**\n\t * After mounting the editor, the variable will contain a reference to the created editor.\n\t * @see: https://ckeditor.com/docs/ckeditor5/latest/api/module_core_editor_editor-Editor.html\n\t */\n\tprivate domContainer = React.createRef<HTMLDivElement>();\n\n\t/**\n\t * Unlocks element in editor semaphore after destroy editor instance.\n\t */\n\tprivate editorSemaphore: LifeCycleElementSemaphore<EditorSemaphoreMountResult<TEditor>> | null = null;\n\n\tconstructor( props: Props<TEditor> ) {\n\t\tsuper( props );\n\n\t\tthis._checkVersion();\n\t}\n\n\t/**\n\t * Checks if the CKEditor version used in the application is compatible with the component.\n\t */\n\tprivate _checkVersion(): void {\n\t\tconst { CKEDITOR_VERSION } = window;\n\n\t\tif ( !CKEDITOR_VERSION ) {\n\t\t\treturn console.warn( 'Cannot find the \"CKEDITOR_VERSION\" in the \"window\" scope.' );\n\t\t}\n\n\t\tconst [ major ] = CKEDITOR_VERSION.split( '.' ).map( Number );\n\n\t\tif ( major >= 42 || CKEDITOR_VERSION.startsWith( '0.0.0' ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconsole.warn( 'The <CKEditor> component requires using CKEditor 5 in version 42+ or nightly build.' );\n\t}\n\n\tprivate get _semaphoreValue(): EditorSemaphoreMountResult<TEditor> | null {\n\t\tconst { editorSemaphore } = this;\n\n\t\treturn editorSemaphore ? editorSemaphore.value : null;\n\t}\n\n\t/**\n\t * An watchdog instance.\n\t */\n\tpublic get watchdog(): EditorWatchdog<TEditor> | EditorWatchdogAdapter<TEditor> | null {\n\t\tconst { _semaphoreValue } = this;\n\n\t\treturn _semaphoreValue ? _semaphoreValue.watchdog : null;\n\t}\n\n\t/**\n\t * An editor instance.\n\t */\n\tpublic get editor(): Editor | null {\n\t\tconst { _semaphoreValue } = this;\n\n\t\treturn _semaphoreValue ? _semaphoreValue.instance : null;\n\t}\n\n\t/**\n\t * The CKEditor component should not be updated by React itself.\n\t * However, if the component identifier changes, the whole structure should be created once again.\n\t */\n\tpublic override shouldComponentUpdate( nextProps: Readonly<Props<TEditor>> ): boolean {\n\t\tconst { props, editorSemaphore } = this;\n\n\t\t// Only when the component identifier changes the whole structure should be re-created once again.\n\t\tif ( nextProps.id !== props.id ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif ( nextProps.disableWatchdog !== props.disableWatchdog ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif ( editorSemaphore ) {\n\t\t\teditorSemaphore.runAfterMount( ( { instance } ) => {\n\t\t\t\tif ( this._shouldUpdateEditorData( props, nextProps, instance ) ) {\n\t\t\t\t\tinstance.data.set( nextProps.data! );\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\tif ( 'disabled' in nextProps ) {\n\t\t\t\teditorSemaphore.runAfterMount( ( { instance } ) => {\n\t\t\t\t\tif ( nextProps.disabled ) {\n\t\t\t\t\t\tinstance.enableReadOnlyMode( REACT_INTEGRATION_READ_ONLY_LOCK_ID );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tinstance.disableReadOnlyMode( REACT_INTEGRATION_READ_ONLY_LOCK_ID );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Initialize the editor when the component is mounted.\n\t */\n\tpublic override componentDidMount(): void {\n\t\tif ( !isContextWatchdogInitializing( this.context ) ) {\n\t\t\tthis._initLifeCycleSemaphore();\n\t\t}\n\t}\n\n\t/**\n\t * Re-render the entire component once again. The old editor will be destroyed and the new one will be created.\n\t */\n\tpublic override componentDidUpdate(): void {\n\t\tif ( !isContextWatchdogInitializing( this.context ) ) {\n\t\t\tthis._initLifeCycleSemaphore();\n\t\t}\n\t}\n\n\t/**\n\t * Destroy the editor before unmounting the component.\n\t */\n\tpublic override componentWillUnmount(): void {\n\t\tthis._unlockLifeCycleSemaphore();\n\t}\n\n\t/**\n\t * Async destroy attached editor and unlock element semaphore.\n\t */\n\tprivate _unlockLifeCycleSemaphore() {\n\t\tif ( this.editorSemaphore ) {\n\t\t\tthis.editorSemaphore.release();\n\t\t\tthis.editorSemaphore = null;\n\t\t}\n\t}\n\n\t/**\n\t * Unlocks previous editor semaphore and creates new one..\n\t */\n\tprivate _initLifeCycleSemaphore() {\n\t\tthis._unlockLifeCycleSemaphore();\n\t\tthis.editorSemaphore = new LifeCycleElementSemaphore( this.domContainer.current!, {\n\t\t\tmount: async () => this._initializeEditor(),\n\t\t\tafterMount: ( { mountResult } ) => {\n\t\t\t\tconst { onReady } = this.props;\n\n\t\t\t\tif ( onReady && this.domContainer.current !== null ) {\n\t\t\t\t\tonReady( mountResult.instance );\n\t\t\t\t}\n\t\t\t},\n\t\t\tunmount: async ( { element, mountResult } ) => {\n\t\t\t\tconst { onAfterDestroy } = this.props;\n\n\t\t\t\ttry {\n\t\t\t\t\tawait this._destroyEditor( mountResult );\n\n\t\t\t\t\t/**\n\t\t\t\t\t * Make sure that nothing left in actual editor element. There can be custom integrations that\n\t\t\t\t\t * appends something to container. Let's reset element every update cycle before mounting another\n\t\t\t\t\t * editor instance.\n\t\t\t\t\t */\n\t\t\t\t\telement.innerHTML = '';\n\t\t\t\t} finally {\n\t\t\t\t\t/**\n\t\t\t\t\t * Broadcast information about destroying current instance. It is useful for removing duplicated\n\t\t\t\t\t * toolbars in decoupled editor mode.\n\t\t\t\t\t */\n\t\t\t\t\tif ( onAfterDestroy ) {\n\t\t\t\t\t\tonAfterDestroy( mountResult.instance );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t}\n\n\t/**\n\t * Render a <div> element which will be replaced by CKEditor.\n\t */\n\tpublic override render(): React.ReactNode {\n\t\treturn (\n\t\t\t<div ref={ this.domContainer }></div>\n\t\t);\n\t}\n\n\t/**\n\t * Initializes the editor by creating a proper watchdog and initializing it with the editor's configuration.\n\t */\n\tprivate async _initializeEditor(): Promise<EditorSemaphoreMountResult<TEditor>> {\n\t\tif ( this.props.disableWatchdog ) {\n\t\t\tconst instance = await this._createEditor( this.domContainer.current!, this._getConfig() );\n\n\t\t\treturn {\n\t\t\t\tinstance: instance as TEditor,\n\t\t\t\twatchdog: null\n\t\t\t};\n\t\t}\n\n\t\tconst watchdog = ( () => {\n\t\t\t// There is small delay where React did not update the context yet but watchdog is already destroyed.\n\t\t\t// However editor should be created again in such case, after receiving new context.\n\t\t\tif ( isContextWatchdogReadyToUse( this.context ) ) {\n\t\t\t\treturn new EditorWatchdogAdapter( this.context.watchdog );\n\t\t\t}\n\n\t\t\treturn new this.props.editor.EditorWatchdog( this.props.editor, this.props.watchdogConfig );\n\t\t} )() as EditorWatchdogAdapter<TEditor>;\n\n\t\tconst totalRestartsRef = {\n\t\t\tcurrent: 0\n\t\t};\n\n\t\twatchdog.setCreator( async ( el, config ) => {\n\t\t\tconst { editorSemaphore } = this;\n\t\t\tconst { onAfterDestroy } = this.props;\n\n\t\t\tif ( totalRestartsRef.current > 0 && onAfterDestroy && editorSemaphore?.value?.instance ) {\n\t\t\t\tonAfterDestroy( editorSemaphore.value.instance );\n\t\t\t}\n\n\t\t\tconst instance = await this._createEditor( el as any, config );\n\n\t\t\t// The editor semaphore can be unavailable at this stage. There is a small chance that the component\n\t\t\t// was destroyed while watchdog was initializing new instance of editor. In such case, we should not\n\t\t\t// call any callbacks or set any values to the semaphore.\n\t\t\tif ( editorSemaphore && totalRestartsRef.current > 0 ) {\n\t\t\t\teditorSemaphore.unsafeSetValue( {\n\t\t\t\t\tinstance,\n\t\t\t\t\twatchdog\n\t\t\t\t} );\n\n\t\t\t\tsetTimeout( () => {\n\t\t\t\t\tif ( this.props.onReady ) {\n\t\t\t\t\t\tthis.props.onReady( watchdog!.editor as TEditor );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\ttotalRestartsRef.current++;\n\t\t\treturn instance;\n\t\t} );\n\n\t\twatchdog.on( 'error', ( _, { error, causesRestart } ) => {\n\t\t\tconst onError = this.props.onError || console.error;\n\t\t\tonError( error, { phase: 'runtime', willEditorRestart: causesRestart } );\n\t\t} );\n\n\t\tawait watchdog\n\t\t\t.create( this.domContainer.current!, this._getConfig() )\n\t\t\t.catch( error => {\n\t\t\t\tconst onError = this.props.onError || console.error;\n\t\t\t\tonError( error, { phase: 'initialization', willEditorRestart: false } );\n\t\t\t} );\n\n\t\treturn {\n\t\t\twatchdog,\n\t\t\tinstance: watchdog!.editor\n\t\t};\n\t}\n\n\t/**\n\t * Creates an editor from the element and configuration.\n\t *\n\t * @param element The source element.\n\t * @param config CKEditor 5 editor configuration.\n\t */\n\tprivate _createEditor( element: HTMLElement | string | Record<string, string>, config: EditorConfig ): Promise<TEditor> {\n\t\tconst { contextItemMetadata } = this.props;\n\n\t\tif ( contextItemMetadata ) {\n\t\t\tconfig = withCKEditorReactContextMetadata( contextItemMetadata, config );\n\t\t}\n\n\t\treturn this.props.editor.create(\n\t\t\telement as HTMLElement,\n\t\t\tappendAllIntegrationPluginsToConfig( config )\n\t\t)\n\t\t\t.then( editor => {\n\t\t\t\tif ( 'disabled' in this.props ) {\n\t\t\t\t\t// Switch to the read-only mode if the `[disabled]` attribute is specified.\n\t\t\t\t\t/* istanbul ignore else -- @preserve */\n\t\t\t\t\tif ( this.props.disabled ) {\n\t\t\t\t\t\teditor.enableReadOnlyMode( REACT_INTEGRATION_READ_ONLY_LOCK_ID );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst modelDocument = editor.model.document;\n\t\t\t\tconst viewDocument = editor.editing.view.document;\n\n\t\t\t\tmodelDocument.on<DocumentChangeEvent>( 'change:data', event => {\n\t\t\t\t\t/* istanbul ignore else -- @preserve */\n\t\t\t\t\tif ( this.props.onChange ) {\n\t\t\t\t\t\tthis.props.onChange( event, editor );\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\t\tviewDocument.on( 'focus', event => {\n\t\t\t\t\t/* istanbul ignore else -- @preserve */\n\t\t\t\t\tif ( this.props.onFocus ) {\n\t\t\t\t\t\tthis.props.onFocus( event, editor );\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\t\tviewDocument.on( 'blur', event => {\n\t\t\t\t\t/* istanbul ignore else -- @preserve */\n\t\t\t\t\tif ( this.props.onBlur ) {\n\t\t\t\t\t\tthis.props.onBlur( event, editor );\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\t\treturn editor;\n\t\t\t} );\n\t}\n\n\t/**\n\t * Destroys the editor by destroying the watchdog.\n\t */\n\tprivate async _destroyEditor( initializeResult: EditorSemaphoreMountResult<Editor> ): Promise<void> {\n\t\tconst { watchdog, instance } = initializeResult;\n\n\t\treturn new Promise<void>( ( resolve, reject ) => {\n\t\t\t// It may happen during the tests that the watchdog instance is not assigned before destroying itself. See: #197.\n\t\t\t//\n\t\t\t// Additionally, we need to find a way to detect if the whole context has been destroyed. As `componentWillUnmount()`\n\t\t\t// could be fired by <CKEditorContext /> and <CKEditor /> at the same time, this `setTimeout()` makes sure\n\t\t\t// that <CKEditorContext /> component will be destroyed first, so during the code execution\n\t\t\t// the `ContextWatchdog#state` would have a correct value. See `EditorWatchdogAdapter#destroy()` for more information.\n\t\t\t/* istanbul ignore next -- @preserve */\n\t\t\tsetTimeout( async () => {\n\t\t\t\ttry {\n\t\t\t\t\tif ( watchdog ) {\n\t\t\t\t\t\tawait watchdog.destroy();\n\t\t\t\t\t\treturn resolve();\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( instance ) {\n\t\t\t\t\t\tawait instance.destroy();\n\t\t\t\t\t\treturn resolve();\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve();\n\t\t\t\t} catch ( e ) {\n\t\t\t\t\tconsole.error( e );\n\t\t\t\t\treject( e );\n\t\t\t\t}\n\t\t\t} );\n\t\t} );\n\t}\n\n\t/**\n\t * Returns true when the editor should be updated.\n\t *\n\t * @param prevProps Previous react's properties.\n\t * @param nextProps React's properties.\n\t * @param editor Current editor instance.\n\t */\n\tprivate _shouldUpdateEditorData( prevProps: Readonly<Props<TEditor>>, nextProps: Readonly<Props<TEditor>>, editor: TEditor ): boolean {\n\t\t// Check whether `nextProps.data` is equal to `this.props.data` is required if somebody defined the `#data`\n\t\t// property as a static string and updated a state of component when the editor's content has been changed.\n\t\t// If we avoid checking those properties, the editor's content will back to the initial value because\n\t\t// the state has been changed and React will call this method.\n\t\tif ( prevProps.data === nextProps.data ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// We should not change data if the editor's content is equal to the `#data` property.\n\t\tif ( editor.data.get() === nextProps.data ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Returns the editor configuration.\n\t */\n\tprivate _getConfig(): EditorConfig {\n\t\tconst config = this.props.config || {};\n\n\t\tif ( this.props.data && config.initialData ) {\n\t\t\tconsole.warn(\n\t\t\t\t'Editor data should be provided either using `config.initialData` or `content` property. ' +\n\t\t\t\t'The config value takes precedence over `content` property and will be used when both are specified.'\n\t\t\t);\n\t\t}\n\n\t\t// Merge two possible ways of providing data into the `config.initialData` field.\n\t\treturn {\n\t\t\t...config,\n\t\t\tinitialData: config.initialData || this.props.data || ''\n\t\t};\n\t}\n\n\tpublic static override contextType = ContextWatchdogContext;\n}\n\n/**\n * TODO this is type space definition for props, the CKEditor.propTypes is a run-time props validation that should match.\n */\nexport interface Props<TEditor extends Editor> {\n\teditor: {\n\t\tcreate( ...args: any ): Promise<TEditor>;\n\t\tEditorWatchdog: typeof EditorWatchdog;\n\t\tContextWatchdog: typeof ContextWatchdog;\n\t};\n\tcontextItemMetadata?: CKEditorConfigContextMetadata;\n\tconfig?: EditorConfig;\n\twatchdogConfig?: WatchdogConfig;\n\tdisableWatchdog?: boolean;\n\tonReady?: ( editor: TEditor ) => void;\n\tonAfterDestroy?: ( editor: TEditor ) => void;\n\tonError?: ( error: Error, details: ErrorDetails ) => void;\n\tonChange?: ( event: EventInfo, editor: TEditor ) => void;\n\tonFocus?: ( event: EventInfo, editor: TEditor ) => void;\n\tonBlur?: ( event: EventInfo, editor: TEditor ) => void;\n\tdata?: string;\n\tdisabled?: boolean;\n\tid?: any;\n}\n\ninterface ErrorDetails {\n\tphase: 'initialization' | 'runtime';\n\twillEditorRestart?: boolean;\n}\n\n/**\n * An adapter aligning the context watchdog API to the editor watchdog API for easier usage.\n */\nexport class EditorWatchdogAdapter<TEditor extends Editor> {\n\t/**\n\t * The context watchdog instance that will be wrapped into editor watchdog API.\n\t */\n\tprivate readonly _contextWatchdog: ContextWatchdog;\n\n\t/**\n\t * A unique id for the adapter to distinguish editor items when using the context watchdog API.\n\t */\n\tprivate readonly _id: string;\n\n\t/**\n\t * A watchdog's editor creator function.\n\t */\n\tprivate _creator?: EditorCreatorFunction;\n\n\t/**\n\t * @param contextWatchdog The context watchdog instance that will be wrapped into editor watchdog API.\n\t */\n\tconstructor( contextWatchdog: ContextWatchdog ) {\n\t\tthis._contextWatchdog = contextWatchdog;\n\t\tthis._id = uid();\n\t}\n\n\t/**\n\t *  @param creator A watchdog's editor creator function.\n\t */\n\tpublic setCreator( creator: EditorCreatorFunction ): void {\n\t\tthis._creator = creator;\n\t}\n\n\t/**\n\t * Adds an editor configuration to the context watchdog registry. Creates an instance of it.\n\t *\n\t * @param sourceElementOrData A source element or data for the new editor.\n\t * @param config CKEditor 5 editor config.\n\t */\n\tpublic create( sourceElementOrData: HTMLElement | string, config: EditorConfig ): Promise<unknown> {\n\t\treturn this._contextWatchdog.add( {\n\t\t\tsourceElementOrData,\n\t\t\tconfig,\n\t\t\tcreator: this._creator!,\n\t\t\tid: this._id,\n\t\t\ttype: 'editor'\n\t\t} );\n\t}\n\n\t/**\n\t * Creates a listener that is attached to context watchdog's item and run when the context watchdog fires.\n\t * Currently works only for the `error` event.\n\t */\n\tpublic on( _: string, callback: ( _: null, data: { error: Error; causesRestart?: boolean } ) => void ): void {\n\t\t// Assume that the event name was error.\n\t\tthis._contextWatchdog.on( 'itemError', ( _, { itemId, error } ) => {\n\t\t\tif ( itemId === this._id ) {\n\t\t\t\tcallback( null, { error, causesRestart: undefined } );\n\t\t\t}\n\t\t} );\n\t}\n\n\tpublic destroy(): Promise<unknown> {\n\t\t// Destroying an editor instance after destroying the Context is handled in the `ContextWatchdog` class.\n\t\t// As `EditorWatchdogAdapter` is an adapter, we should not destroy the editor manually.\n\t\t// Otherwise, it causes that the editor is destroyed twice. However, there is a case, when the editor\n\t\t// needs to be removed from the context, without destroying the context itself. We may assume the following\n\t\t// relations with `ContextWatchdog#state`:\n\t\t//\n\t\t// a) `ContextWatchdog#state` === 'ready' - context is not destroyed; it's safe to destroy the editor manually.\n\t\t// b) `ContextWatchdog#state` === 'destroyed' - context is destroyed; let `ContextWatchdog` handle the whole process.\n\t\t//\n\t\t// See #354 for more information.\n\t\tif ( this._contextWatchdog.state === 'ready' ) {\n\t\t\treturn this._contextWatchdog.remove( this._id );\n\t\t}\n\n\t\treturn Promise.resolve();\n\t}\n\n\t/**\n\t * An editor instance.\n\t */\n\tpublic get editor(): TEditor {\n\t\treturn this._contextWatchdog.getItem( this._id ) as TEditor;\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\n\nimport { useRef, useState, type RefObject } from 'react';\nimport type { LifeCycleElementSemaphore, LifeCycleAfterMountCallback } from './LifeCycleElementSemaphore.js';\n\n/**\n * When using the `useState` approach, a new instance of the semaphore must be set based on the previous\n * one within the `setState` callback, as shown in this example:\n *\n * \t\tsetState( prevSemaphore => ... )\n *\n * The issue arises from the uncertainty of whether React has batched and cancelled some `setState` calls.\n * This means that setting the state with a semaphore three times might result in the collapsing of these three calls into a single one.\n *\n * Although this may not seem like a significant issue in theory, it can lead to a multitude of minor issues in practice that may\n * generate race conditions. This is because semaphores handle batching independently.\n *\n * A solution involving refs is safer in terms of preserving object references. In other words, `semaphoreRef.current` is guaranteed to\n * always point to the most recent instance of the semaphore.\n */\nexport const useLifeCycleSemaphoreSyncRef = <R extends object>(): LifeCycleSemaphoreSyncRefResult<R> => {\n\tconst semaphoreRef = useRef<LifeCycleElementSemaphore<R> | null>( null );\n\tconst [ revision, setRevision ] = useState( () => Date.now() );\n\n\tconst refresh = () => {\n\t\tsetRevision( Date.now() );\n\t};\n\n\tconst release = ( rerender: boolean = true ) => {\n\t\tif ( semaphoreRef.current ) {\n\t\t\tsemaphoreRef.current.release();\n\t\t\tsemaphoreRef.current = null;\n\t\t}\n\n\t\tif ( rerender ) {\n\t\t\tsetRevision( Date.now() );\n\t\t}\n\t};\n\n\tconst unsafeSetValue = ( value: R ) => {\n\t\tsemaphoreRef.current?.unsafeSetValue( value );\n\t\trefresh();\n\t};\n\n\tconst runAfterMount = ( callback: LifeCycleAfterMountCallback<R> ) => {\n\t\tif ( semaphoreRef.current ) {\n\t\t\tsemaphoreRef.current.runAfterMount( callback );\n\t\t}\n\t};\n\n\tconst replace = ( newSemaphore: () => LifeCycleElementSemaphore<R> ) => {\n\t\trelease( false );\n\t\tsemaphoreRef.current = newSemaphore();\n\n\t\trefresh();\n\t\trunAfterMount( refresh );\n\t};\n\n\tconst createAttributeRef = <K extends keyof R>( key: K ): RefObject<R[ K ]> => ( {\n\t\tget current() {\n\t\t\tif ( !semaphoreRef.current || !semaphoreRef.current.value ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn semaphoreRef.current.value[ key ];\n\t\t}\n\t} );\n\n\treturn {\n\t\tget current() {\n\t\t\treturn semaphoreRef.current;\n\t\t},\n\t\trevision,\n\t\tcreateAttributeRef,\n\t\tunsafeSetValue,\n\t\trelease,\n\t\treplace,\n\t\trunAfterMount\n\t};\n};\n\nexport type LifeCycleSemaphoreSyncRefResult<R> = RefObject<LifeCycleElementSemaphore<R>> & {\n\trevision: number;\n\tunsafeSetValue: ( value: R ) => void;\n\trunAfterMount: ( callback: LifeCycleAfterMountCallback<R> ) => void;\n\trelease: ( rerender?: boolean ) => void;\n\treplace: ( newSemaphore: () => LifeCycleElementSemaphore<R> ) => void;\n\tcreateAttributeRef: <K extends keyof R>( key: K ) => RefObject<R[ K ]>;\n};\n","/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\n\nimport type { MutableRefObject } from 'react';\n\ntype CallbackRef<T> = ( element: T ) => void;\n\ntype ReactRef<T> = CallbackRef<T | null> | MutableRefObject<T | null> | null;\n\n/**\n * Combine multiple react refs into one.\n */\nexport function mergeRefs<T>( ...refs: Array<ReactRef<T>> ): CallbackRef<T> {\n\treturn value => {\n\t\trefs.forEach( ref => {\n\t\t\tif ( typeof ref === 'function' ) {\n\t\t\t\tref( value );\n\t\t\t} else if ( ref != null ) {\n\t\t\t\tref.current = value;\n\t\t\t}\n\t\t} );\n\t};\n}\n","/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\n\nimport { useState, type DependencyList } from 'react';\nimport { shallowCompareArrays } from '@ckeditor/ckeditor5-integrations-common';\n\n/**\n * Triggers an effect immediately if the dependencies change (during rendering of component).\n *\n * @param fn The effect function to execute.\n * @param deps The dependency list.\n */\nexport const useInstantEffect = ( fn: VoidFunction, deps: DependencyList ): void => {\n\tconst [ prevDeps, setDeps ] = useState<any>( null );\n\n\tif ( !shallowCompareArrays( prevDeps, deps ) ) {\n\t\tfn();\n\t\tsetDeps( [ ...deps ] );\n\t}\n};\n","/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\n\nimport type { DependencyList } from 'react';\nimport type { LifeCycleElementSemaphore } from '../lifecycle/LifeCycleElementSemaphore.js';\n\nimport { useInstantEffect } from './useInstantEffect.js';\n\n/**\n * `useEffect` alternative but executed after mounting of editor.\n */\nexport const useInstantEditorEffect = <R>(\n\tsemaphore: Pick<LifeCycleElementSemaphore<R>, 'runAfterMount'> | null,\n\tfn: ( mountResult: R ) => void,\n\tdeps: DependencyList\n): void => {\n\tuseInstantEffect( () => {\n\t\tif ( semaphore ) {\n\t\t\tsemaphore.runAfterMount( fn );\n\t\t}\n\t}, [ semaphore, ...deps ] );\n};\n","/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\n\nimport React, {\n\tforwardRef, useState, useEffect, useRef, useContext, useCallback, memo,\n\ttype Dispatch, type SetStateAction, type RefObject, type JSX\n} from 'react';\n\nimport { overwriteArray, overwriteObject, uniq } from '@ckeditor/ckeditor5-integrations-common';\n\nimport type {\n\tInlineEditableUIView,\n\tEditorConfig,\n\tDocumentChangeEvent,\n\tWriter,\n\tRootElement,\n\tWatchdogConfig,\n\tAddRootEvent,\n\tDetachRootEvent,\n\tMultiRootEditor,\n\tEventInfo\n} from 'ckeditor5';\n\nimport { ContextWatchdogContext, isContextWatchdogReadyToUse } from './context/ckeditorcontext.js';\nimport { EditorWatchdogAdapter } from './ckeditor.js';\n\nimport type { EditorSemaphoreMountResult } from './lifecycle/LifeCycleEditorSemaphore.js';\n\nimport { useLifeCycleSemaphoreSyncRef, type LifeCycleSemaphoreSyncRefResult } from './lifecycle/useLifeCycleSemaphoreSyncRef.js';\nimport { mergeRefs } from './utils/mergeRefs.js';\nimport { LifeCycleElementSemaphore } from './lifecycle/LifeCycleElementSemaphore.js';\nimport { useRefSafeCallback } from './hooks/useRefSafeCallback.js';\nimport { useInstantEditorEffect } from './hooks/useInstantEditorEffect.js';\n\nimport { appendAllIntegrationPluginsToConfig } from './plugins/appendAllIntegrationPluginsToConfig.js';\n\nconst REACT_INTEGRATION_READ_ONLY_LOCK_ID = 'Lock from React integration (@ckeditor/ckeditor5-react)';\n\n/* eslint-disable @typescript-eslint/no-use-before-define */\nconst useMultiRootEditor = ( props: MultiRootHookProps ): MultiRootHookReturns => {\n\tconst semaphoreElementRef = useRef<HTMLElement>( props.semaphoreElement || null );\n\tconst semaphore = useLifeCycleSemaphoreSyncRef<LifeCycleMountResult>();\n\n\tconst editorRefs: LifeCycleSemaphoreRefs<MultiRootEditor> = {\n\t\twatchdog: semaphore.createAttributeRef( 'watchdog' ),\n\t\tinstance: semaphore.createAttributeRef( 'instance' )\n\t};\n\n\tconst context = useContext( ContextWatchdogContext );\n\n\t// List of editor root elements.\n\tconst [ roots, setRoots ] = useState<Array<string>>( () => Object.keys( props.data ) );\n\n\t// Current editor data. An object where each key is a root name and the value is the root content.\n\tconst [ data, setData ] = useState<Record<string, string>>( { ...props.data } );\n\n\t// Current roots attributes. An object where each key is a root name and the value is an object with root attributes.\n\tconst [ attributes, setAttributes ] = useState<Record<string, Record<string, unknown>>>( { ...props.rootsAttributes } );\n\n\tconst shouldUpdateEditor = useRef<boolean>( true );\n\n\t/**\n\t * It's possible to unmount `useMultiRootEditor` with created editor and `elements` that are not attached to any React node.\n\t * It means that CKEditor will try to destroy editor and all it's roots in destructor. It will throw an error because\n\t * `editables` are not attached to any React node and their elements references are null. To prevent this error we need to\n\t * force assign `editables` to fake elements before destroying editor.\n\t *\n\t * See: https://github.com/ckeditor/ckeditor5/issues/16561\n\t */\n\tconst forceAssignFakeEditableElements = () => {\n\t\tconst editor = editorRefs.instance.current;\n\n\t\tif ( !editor ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst initializeEditableWithFakeElement = ( editable: InlineEditableUIView ) => {\n\t\t\tif ( editable.name && !editor.editing.view.getDomRoot( editable.name ) ) {\n\t\t\t\teditor.editing.view.attachDomRoot( document.createElement( 'div' ), editable.name );\n\t\t\t}\n\t\t};\n\n\t\tObject\n\t\t\t.values( editor.ui.view.editables )\n\t\t\t.forEach( initializeEditableWithFakeElement );\n\t};\n\n\tuseEffect( () => {\n\t\tconst semaphoreElement = semaphoreElementRef.current;\n\n\t\t// Check if parent context is ready (only if it is provided).\n\t\tif ( context && !isContextWatchdogReadyToUse( context ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Check if hook internal state or attributes are not ready yet.\n\t\tif ( !semaphoreElement || props.isLayoutReady === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\tsemaphore.replace( () => new LifeCycleElementSemaphore( semaphoreElement, {\n\t\t\tmount: _initializeEditor,\n\t\t\tafterMount: ( { mountResult } ) => {\n\t\t\t\tconst { onReady } = props;\n\n\t\t\t\tif ( onReady && semaphoreElementRef.current !== null ) {\n\t\t\t\t\tonReady( mountResult.instance );\n\t\t\t\t}\n\t\t\t},\n\t\t\tunmount: async ( { element, mountResult } ) => {\n\t\t\t\tconst { onAfterDestroy } = props;\n\n\t\t\t\ttry {\n\t\t\t\t\tawait _destroyEditor( mountResult );\n\n\t\t\t\t\t/**\n\t\t\t\t\t * Make sure that nothing left in actual editor element. There can be custom integrations that\n\t\t\t\t\t * appends something to container. Let's reset element every update cycle before mounting another\n\t\t\t\t\t * editor instance.\n\t\t\t\t\t */\n\t\t\t\t\telement.innerHTML = '';\n\t\t\t\t} finally {\n\t\t\t\t\t/**\n\t\t\t\t\t * Broadcast information about destroying current instance. It is useful for removing duplicated\n\t\t\t\t\t * toolbars in decoupled editor mode.\n\t\t\t\t\t */\n\t\t\t\t\tif ( onAfterDestroy ) {\n\t\t\t\t\t\tonAfterDestroy( mountResult.instance );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} ) );\n\n\t\treturn () => {\n\t\t\tforceAssignFakeEditableElements();\n\t\t\tsemaphore.release( false );\n\t\t};\n\t}, [ props.id, props.isLayoutReady, context?.status ] );\n\n\t/**\n\t * Returns the editor configuration.\n\t */\n\tconst _getConfig = (): EditorConfig => {\n\t\tconst config = props.config || {};\n\n\t\tif ( props.data && config.initialData ) {\n\t\t\tconsole.warn(\n\t\t\t\t'Editor data should be provided either using `config.initialData` or `data` property. ' +\n\t\t\t\t'The config value takes precedence over `data` property and will be used when both are specified.'\n\t\t\t);\n\t\t}\n\n\t\treturn {\n\t\t\t...config,\n\t\t\trootsAttributes: attributes\n\t\t};\n\t};\n\n\t/**\n\t * Callback function for handling changed data and attributes in the editor.\n\t */\n\tconst onChangeData = useRefSafeCallback( ( editor: MultiRootEditor, event: EventInfo ): void => {\n\t\tconst modelDocument = editor!.model.document;\n\n\t\tif ( !props.disableTwoWayDataBinding ) {\n\t\t\tconst newData: Record<string, string> = {};\n\t\t\tconst newAttributes: Record<string, Record<string, unknown>> = {};\n\n\t\t\tmodelDocument.differ.getChanges()\n\t\t\t\t.forEach( change => {\n\t\t\t\t\tlet root: RootElement;\n\n\t\t\t\t\t/* istanbul ignore else -- @preserve */\n\t\t\t\t\tif ( change.type == 'insert' || change.type == 'remove' ) {\n\t\t\t\t\t\troot = change.position.root as RootElement;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Must be `attribute` diff item.\n\t\t\t\t\t\troot = change.range.root as RootElement;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Getting data from a not attached root will trigger a warning.\n\t\t\t\t\t// There is another callback for handling detached roots.\n\t\t\t\t\tif ( !root.isAttached() ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst { rootName } = root;\n\n\t\t\t\t\tnewData[ rootName ] = editor!.getData( { rootName } );\n\t\t\t\t} );\n\n\t\t\tmodelDocument.differ.getChangedRoots()\n\t\t\t\t.forEach( changedRoot => {\n\t\t\t\t\t// Ignore added and removed roots. They are handled by a different function.\n\t\t\t\t\t// Only register if roots attributes changed.\n\t\t\t\t\tif ( changedRoot.state ) {\n\t\t\t\t\t\tif ( newData[ changedRoot.name ] !== undefined ) {\n\t\t\t\t\t\t\tdelete newData[ changedRoot.name ];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst rootName = changedRoot.name;\n\n\t\t\t\t\tnewAttributes[ rootName ] = editor!.getRootAttributes( rootName );\n\t\t\t\t} );\n\n\t\t\tif ( Object.keys( newData ).length ) {\n\t\t\t\tsetData( previousData => ( { ...previousData, ...newData } ) );\n\t\t\t}\n\n\t\t\tif ( Object.keys( newAttributes ).length ) {\n\t\t\t\tsetAttributes( previousAttributes => ( { ...previousAttributes, ...newAttributes } ) );\n\t\t\t}\n\t\t}\n\n\t\t/* istanbul ignore else -- @preserve */\n\t\tif ( props.onChange ) {\n\t\t\tprops.onChange( event, editor! );\n\t\t}\n\t} );\n\n\t/**\n\t * Callback function for handling an added root.\n\t */\n\tconst onAddRoot = useRefSafeCallback( ( editor: MultiRootEditor, _evt: EventInfo, root: RootElement ): void => {\n\t\tconst rootName = root.rootName;\n\n\t\tif ( !props.disableTwoWayDataBinding ) {\n\t\t\tsetData( previousData =>\n\t\t\t\t( { ...previousData, [ rootName ]: editor!.getData( { rootName } ) } )\n\t\t\t);\n\n\t\t\tsetAttributes( previousAttributes =>\n\t\t\t\t( { ...previousAttributes, [ rootName ]: editor!.getRootAttributes( rootName ) } )\n\t\t\t);\n\t\t}\n\n\t\tsetRoots( prevRoots => uniq( [ ...prevRoots, root.rootName ] ) );\n\t} );\n\n\t/**\n\t * Callback function for handling a detached root.\n\t */\n\tconst onDetachRoot = useRefSafeCallback( ( _editor: MultiRootEditor, _evt: EventInfo, root: RootElement ): void => {\n\t\tconst rootName = root.rootName;\n\n\t\tif ( !props.disableTwoWayDataBinding ) {\n\t\t\tsetData( previousData => {\n\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t\t\t\tconst { [ rootName! ]: _, ...newData } = previousData;\n\n\t\t\t\treturn { ...newData };\n\t\t\t} );\n\n\t\t\tsetAttributes( previousAttributes => {\n\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t\t\t\tconst { [ rootName! ]: _, ...newAttributes } = previousAttributes;\n\n\t\t\t\treturn { ...newAttributes };\n\t\t\t} );\n\t\t}\n\n\t\tsetRoots( prevRoots => prevRoots.filter( root => root !== rootName ) );\n\t} );\n\n\t/**\n\t * Creates an editor using initial elements or data, and configuration.\n\t *\n\t * @param initialData The initial data.\n\t * @param config CKEditor 5 editor configuration.\n\t */\n\tconst _createEditor = useRefSafeCallback( (\n\t\tinitialData: Record<string, string> | Record<string, HTMLElement>,\n\t\tconfig: EditorConfig\n\t): Promise<MultiRootEditor> => {\n\t\toverwriteObject( { ...props.rootsAttributes }, attributes );\n\t\toverwriteObject( { ...props.data }, data );\n\t\toverwriteArray( Object.keys( props.data ), roots );\n\n\t\treturn props.editor.create(\n\t\t\tinitialData,\n\t\t\tappendAllIntegrationPluginsToConfig( config )\n\t\t)\n\t\t\t.then( ( editor: MultiRootEditor ) => {\n\t\t\t\tconst editorData = editor.getFullData();\n\n\t\t\t\t// Rerender will be called anyway.\n\t\t\t\toverwriteObject( { ...editorData }, data );\n\t\t\t\toverwriteObject( { ...editor.getRootsAttributes() }, attributes );\n\t\t\t\toverwriteArray( Object.keys( editorData ), roots );\n\n\t\t\t\tif ( props.disabled ) {\n\t\t\t\t\t// Switch to the read-only mode if the `[disabled]` attribute is specified.\n\t\t\t\t\t/* istanbul ignore else -- @preserve */\n\t\t\t\t\teditor.enableReadOnlyMode( REACT_INTEGRATION_READ_ONLY_LOCK_ID );\n\t\t\t\t}\n\n\t\t\t\tconst modelDocument = editor.model.document;\n\t\t\t\tconst viewDocument = editor.editing.view.document;\n\n\t\t\t\tmodelDocument.on<DocumentChangeEvent>( 'change:data', evt => onChangeData( editor, evt ) );\n\n\t\t\t\teditor.on<AddRootEvent>( 'addRoot', ( evt, root ) => onAddRoot( editor, evt, root ) );\n\t\t\t\teditor.on<DetachRootEvent>( 'detachRoot', ( evt, root ) => onDetachRoot( editor, evt, root ) );\n\n\t\t\t\tviewDocument.on( 'focus', event => {\n\t\t\t\t\t/* istanbul ignore else -- @preserve */\n\t\t\t\t\tif ( props.onFocus ) {\n\t\t\t\t\t\tprops.onFocus( event, editor );\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\t\tviewDocument.on( 'blur', event => {\n\t\t\t\t\t/* istanbul ignore else -- @preserve */\n\t\t\t\t\tif ( props.onBlur ) {\n\t\t\t\t\t\tprops.onBlur( event, editor );\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\t\treturn editor;\n\t\t\t} );\n\t} );\n\n\t/**\n\t * Destroys the editor by destroying the watchdog.\n\t */\n\tconst _destroyEditor = ( initializeResult: EditorSemaphoreMountResult<MultiRootEditor> ): Promise<void> => {\n\t\tconst { watchdog, instance } = initializeResult;\n\n\t\treturn new Promise<void>( ( resolve, reject ) => {\n\t\t\t// It may happen during the tests that the watchdog instance is not assigned before destroying itself. See: #197.\n\t\t\t//\n\t\t\t// Additionally, we need to find a way to detect if the whole context has been destroyed. As `componentWillUnmount()`\n\t\t\t// could be fired by <CKEditorContext /> and <CKEditor /> at the same time, this `setTimeout()` makes sure\n\t\t\t// that <CKEditorContext /> component will be destroyed first, so during the code execution\n\t\t\t// the `ContextWatchdog#state` would have a correct value. See `EditorWatchdogAdapter#destroy()` for more information.\n\t\t\t/* istanbul ignore next -- @preserve */\n\t\t\tsetTimeout( async () => {\n\t\t\t\ttry {\n\t\t\t\t\tif ( watchdog ) {\n\t\t\t\t\t\tawait watchdog.destroy();\n\t\t\t\t\t\treturn resolve();\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( instance ) {\n\t\t\t\t\t\tawait instance.destroy();\n\t\t\t\t\t\treturn resolve();\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve();\n\t\t\t\t} catch ( e ) {\n\t\t\t\t\tconsole.error( e );\n\t\t\t\t\treject( e );\n\t\t\t\t}\n\t\t\t} );\n\t\t} );\n\t};\n\n\t/**\n\t * Initializes the editor by creating a proper watchdog and initializing it with the editor's configuration.\n\t */\n\tconst _initializeEditor = async (): Promise<LifeCycleMountResult> => {\n\t\tif ( props.disableWatchdog ) {\n\t\t\tconst instance = await _createEditor( props.data as any, _getConfig() );\n\n\t\t\treturn {\n\t\t\t\tinstance: instance as MultiRootEditor,\n\t\t\t\twatchdog: null\n\t\t\t};\n\t\t}\n\n\t\tconst watchdog = ( () => {\n\t\t\tif ( isContextWatchdogReadyToUse( context ) ) {\n\t\t\t\treturn new EditorWatchdogAdapter( context.watchdog );\n\t\t\t}\n\n\t\t\treturn new props.editor.EditorWatchdog( props.editor, props.watchdogConfig );\n\t\t} )() as EditorWatchdogAdapter<MultiRootEditor>;\n\n\t\tconst totalRestartsRef = {\n\t\t\tcurrent: 0\n\t\t};\n\n\t\t// Keeping using `data` from creator function callback seems to be a good idea in theory,\n\t\t// but in practice, it leads to instability. The `data` object can be changed during the editor\n\t\t// initialization, which can lead to unexpected reset of value in the editor, that do not match\n\t\t// with the current react state. To prevent this, we are using the `data` from the hook state.\n\t\t// It's not super optimal, but it's the most stable solution at this moment.\n\t\t// See more: https://github.com/ckeditor/ckeditor5-react/issues/542\n\t\twatchdog.setCreator( async ( _, config ) => {\n\t\t\tconst { onAfterDestroy } = props;\n\n\t\t\tif ( totalRestartsRef.current > 0 && onAfterDestroy && editorRefs.instance.current ) {\n\t\t\t\tonAfterDestroy( editorRefs.instance.current );\n\t\t\t}\n\n\t\t\tconst instance = await _createEditor( data as any, config );\n\n\t\t\tif ( totalRestartsRef.current > 0 ) {\n\t\t\t\tsemaphore.unsafeSetValue( {\n\t\t\t\t\tinstance,\n\t\t\t\t\twatchdog\n\t\t\t\t} );\n\n\t\t\t\tsetTimeout( () => {\n\t\t\t\t\t/* istanbul ignore next -- @preserve */\n\t\t\t\t\tif ( props.onReady ) {\n\t\t\t\t\t\tprops.onReady( watchdog!.editor );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\ttotalRestartsRef.current++;\n\t\t\treturn instance;\n\t\t} );\n\n\t\twatchdog.on( 'error', ( _, { error, causesRestart } ) => {\n\t\t\tconst onError = props.onError || console.error;\n\t\t\tonError( error, { phase: 'runtime', willEditorRestart: causesRestart } );\n\t\t} );\n\n\t\tawait watchdog\n\t\t\t.create( data as any, _getConfig() )\n\t\t\t.catch( error => {\n\t\t\t\tconst onError = props.onError || console.error;\n\t\t\t\tonError( error, { phase: 'initialization', willEditorRestart: false } );\n\t\t\t\tthrow error;\n\t\t\t} );\n\n\t\treturn {\n\t\t\twatchdog,\n\t\t\tinstance: watchdog!.editor\n\t\t};\n\t};\n\n\tconst _getStateDiff = (\n\t\tpreviousState: Record<string, unknown>,\n\t\tnewState: Record<string, unknown>\n\t): {\n\t\taddedKeys: Array<string>;\n\t\tremovedKeys: Array<string>;\n\t} => {\n\t\tconst previousStateKeys = Object.keys( previousState );\n\t\tconst newStateKeys = Object.keys( newState );\n\n\t\treturn {\n\t\t\taddedKeys: newStateKeys.filter( key => !previousStateKeys.includes( key ) ),\n\t\t\tremovedKeys: previousStateKeys.filter( key => !newStateKeys.includes( key ) )\n\t\t};\n\t};\n\n\tconst _externalSetData: Dispatch<SetStateAction<Record<string, string>>> = useCallback(\n\t\tnewData => {\n\t\t\tsemaphore.runAfterMount( () => {\n\t\t\t\tshouldUpdateEditor.current = true;\n\t\t\t\tsetData( newData );\n\t\t\t} );\n\t\t},\n\t\t[ setData ]\n\t);\n\n\tconst _externalSetAttributes: Dispatch<SetStateAction<Record<string, Record<string, unknown>>>> = useCallback(\n\t\tnewAttributes => {\n\t\t\tsemaphore.runAfterMount( () => {\n\t\t\t\tshouldUpdateEditor.current = true;\n\t\t\t\tsetAttributes( newAttributes );\n\t\t\t} );\n\t\t},\n\t\t[ setAttributes ]\n\t);\n\n\tconst toolbarElement = (\n\t\t<EditorToolbarWrapper\n\t\t\tref={ semaphoreElementRef }\n\t\t\teditor={editorRefs.instance.current}\n\t\t/>\n\t);\n\n\tuseInstantEditorEffect( semaphore.current, ( { instance } ) => {\n\t\tif ( props.disabled ) {\n\t\t\tinstance.enableReadOnlyMode( REACT_INTEGRATION_READ_ONLY_LOCK_ID );\n\t\t} else {\n\t\t\tinstance.disableReadOnlyMode( REACT_INTEGRATION_READ_ONLY_LOCK_ID );\n\t\t}\n\t}, [ props.disabled ] );\n\n\tuseInstantEditorEffect( semaphore.current, ( { instance } ) => {\n\t\t// Editor should be only updated when the changes come from the integrator React application.\n\t\tif ( shouldUpdateEditor.current ) {\n\t\t\tshouldUpdateEditor.current = false;\n\n\t\t\tconst dataKeys = Object.keys( data );\n\t\t\tconst attributesKeys = Object.keys( attributes );\n\n\t\t\t// Check if `data` and `attributes` have the same keys.\n\t\t\t//\n\t\t\t// It prevents the addition of attributes for non-existing roots.\n\t\t\t// If the `data` object has a different set of keys, an error will not be thrown\n\t\t\t// since the attributes will be removed/added during root initialization/destruction.\n\t\t\tif ( !dataKeys.every( key => attributesKeys.includes( key ) ) ) {\n\t\t\t\tconsole.error( '`data` and `attributes` objects must have the same keys (roots).' );\n\t\t\t\tthrow new Error( '`data` and `attributes` objects must have the same keys (roots).' );\n\t\t\t}\n\n\t\t\tconst editorData = instance.getFullData();\n\t\t\tconst editorAttributes = instance.getRootsAttributes();\n\n\t\t\tconst {\n\t\t\t\taddedKeys: newRoots,\n\t\t\t\tremovedKeys: removedRoots\n\t\t\t} = _getStateDiff(\n\t\t\t\teditorData,\n\t\t\t\tdata || /* istanbul ignore next -- @preserve: It should never happen, data should be always filled. */ {}\n\t\t\t);\n\n\t\t\tconst modifiedRoots = dataKeys.filter( rootName =>\n\t\t\t\teditorData[ rootName ] !== undefined &&\n\t\t\t\tJSON.stringify( editorData[ rootName ] ) !== JSON.stringify( data[ rootName ] )\n\t\t\t);\n\n\t\t\tconst rootsWithChangedAttributes = attributesKeys.filter( rootName =>\n\t\t\t\tJSON.stringify( editorAttributes[ rootName ] ) !== JSON.stringify( attributes[ rootName ] ) );\n\n\t\t\tconst _handleNewRoots = ( roots: Array<string> ) => {\n\t\t\t\troots.forEach( rootName => {\n\t\t\t\t\tinstance!.addRoot( rootName, {\n\t\t\t\t\t\tdata: data[ rootName ] || '',\n\t\t\t\t\t\tattributes: attributes?.[ rootName ] ||\n\t\t\t\t\t\t/* istanbul ignore next -- @preserve: attributes should be in sync with root keys */ {},\n\t\t\t\t\t\tisUndoable: true\n\t\t\t\t\t} );\n\t\t\t\t} );\n\t\t\t};\n\n\t\t\tconst _handleRemovedRoots = ( roots: Array<string> ) => {\n\t\t\t\troots.forEach( rootName => {\n\t\t\t\t\tinstance!.detachRoot( rootName, true );\n\t\t\t\t} );\n\t\t\t};\n\n\t\t\tconst _updateEditorData = ( roots: Array<string> ) => {\n\t\t\t\tconst dataToUpdate = roots.reduce(\n\t\t\t\t\t( result, rootName ) => ( { ...result, [ rootName ]: data[ rootName ] } ),\n\t\t\t\t\tObject.create( null )\n\t\t\t\t);\n\t\t\t\tinstance.data.set( dataToUpdate, { suppressErrorInCollaboration: true } as any );\n\t\t\t};\n\n\t\t\tconst _updateEditorAttributes = ( writer: Writer, roots: Array<string> ) => {\n\t\t\t\troots.forEach( rootName => {\n\t\t\t\t\tObject.keys( attributes![ rootName ] ).forEach( attr => {\n\t\t\t\t\t\tinstance.registerRootAttribute( attr );\n\t\t\t\t\t} );\n\n\t\t\t\t\twriter.clearAttributes( instance.model.document.getRoot( rootName )! );\n\t\t\t\t\twriter.setAttributes( attributes![ rootName ], instance.model.document.getRoot( rootName )! );\n\t\t\t\t} );\n\t\t\t};\n\n\t\t\t// React struggles with rerendering during `instance.model.change` callbacks.\n\t\t\tsetTimeout( () => {\n\t\t\t\tinstance.model.change( writer => {\n\t\t\t\t\t_handleNewRoots( newRoots );\n\t\t\t\t\t_handleRemovedRoots( removedRoots );\n\n\t\t\t\t\tif ( modifiedRoots.length ) {\n\t\t\t\t\t\t_updateEditorData( modifiedRoots );\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( rootsWithChangedAttributes.length ) {\n\t\t\t\t\t\t_updateEditorAttributes( writer, rootsWithChangedAttributes );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t} );\n\t\t}\n\t}, [ data, attributes ] );\n\n\tconst editableElements = roots.map(\n\t\trootName => (\n\t\t\t<EditorEditable\n\t\t\t\tkey={rootName}\n\t\t\t\tid={rootName}\n\t\t\t\trootName={rootName}\n\t\t\t\tsemaphore={semaphore}\n\t\t\t/>\n\t\t)\n\t);\n\n\treturn {\n\t\teditor: editorRefs.instance.current,\n\t\teditableElements,\n\t\ttoolbarElement,\n\t\tdata, setData: _externalSetData,\n\t\tattributes, setAttributes: _externalSetAttributes\n\t};\n};\n\nexport const EditorEditable = memo( forwardRef( ( { id, semaphore, rootName }: {\n\tid: string;\n\trootName: string;\n\tsemaphore: LifeCycleSemaphoreSyncRefResult<LifeCycleMountResult>;\n}, ref ) => {\n\tconst innerRef = useRef<HTMLDivElement>( null );\n\n\tuseEffect( () => {\n\t\tlet editable: InlineEditableUIView | null;\n\t\tlet editor: MultiRootEditor | null;\n\n\t\tsemaphore.runAfterMount( ( { instance } ) => {\n\t\t\tif ( !innerRef.current ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\teditor = instance;\n\n\t\t\tconst { ui, model } = editor;\n\t\t\tconst root = model.document.getRoot( rootName );\n\n\t\t\tif ( root && editor.ui.getEditableElement( rootName ) ) {\n\t\t\t\teditor.detachEditable( root );\n\t\t\t}\n\n\t\t\teditable = ui.view.createEditable( rootName, innerRef.current );\n\t\t\tui.addEditable( editable );\n\n\t\t\tinstance.editing.view.forceRender();\n\t\t} );\n\n\t\treturn () => {\n\t\t\tif ( editor && editor.state !== 'destroyed' && innerRef.current ) {\n\t\t\t\tconst root = editor.model.document.getRoot( rootName );\n\n\t\t\t\t/* istanbul ignore else -- @preserve */\n\t\t\t\tif ( root ) {\n\t\t\t\t\teditor.detachEditable( root );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}, [ semaphore.revision ] );\n\n\treturn (\n\t\t<div\n\t\t\tkey={semaphore.revision}\n\t\t\tid={id}\n\t\t\tref={ mergeRefs( ref, innerRef ) }\n\t\t/>\n\t);\n} ) );\n\nEditorEditable.displayName = 'EditorEditable';\n\nexport const EditorToolbarWrapper = forwardRef( ( { editor }: any, ref ) => {\n\tconst toolbarRef = useRef<HTMLDivElement>( null );\n\n\tuseEffect( () => {\n\t\tconst toolbarContainer = toolbarRef.current;\n\n\t\tif ( !editor || !toolbarContainer ) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst element = editor.ui.view.toolbar.element!;\n\n\t\ttoolbarContainer.appendChild( element! );\n\n\t\treturn () => {\n\t\t\tif ( toolbarContainer.contains( element ) ) {\n\t\t\t\ttoolbarContainer.removeChild( element! );\n\t\t\t}\n\t\t};\n\t}, [ editor && editor.id ] );\n\n\treturn <div ref={mergeRefs( toolbarRef, ref )}></div>;\n} );\n\nEditorToolbarWrapper.displayName = 'EditorToolbarWrapper';\n\nexport default useMultiRootEditor;\n\ntype LifeCycleMountResult = EditorSemaphoreMountResult<MultiRootEditor>;\n\ntype LifeCycleSemaphoreRefs<TEditor extends MultiRootEditor> = {\n\t[ K in keyof EditorSemaphoreMountResult<TEditor> ]: RefObject<EditorSemaphoreMountResult<TEditor>[ K ]>\n};\n\ninterface ErrorDetails {\n\tphase: 'initialization' | 'runtime';\n\twillEditorRestart?: boolean;\n}\n\nexport type MultiRootHookProps = {\n\tid?: any;\n\tsemaphoreElement?: HTMLElement;\n\n\tisLayoutReady?: boolean;\n\tdisabled?: boolean;\n\tdata: Record<string, string>;\n\trootsAttributes?: Record<string, Record<string, unknown>>;\n\teditor: typeof MultiRootEditor;\n\twatchdogConfig?: WatchdogConfig;\n\tdisableWatchdog?: boolean;\n\tdisableTwoWayDataBinding?: boolean;\n\n\tonReady?: ( editor: MultiRootEditor ) => void;\n\tonAfterDestroy?: ( editor: MultiRootEditor ) => void;\n\tonError?: ( error: Error, details: ErrorDetails ) => void;\n\tonChange?: ( event: EventInfo, editor: MultiRootEditor ) => void;\n\tonFocus?: ( event: EventInfo, editor: MultiRootEditor ) => void;\n\tonBlur?: ( event: EventInfo, editor: MultiRootEditor ) => void;\n\n\tconfig?: Record<string, unknown>;\n};\n\nexport type MultiRootHookReturns = {\n\teditor: MultiRootEditor | null;\n\teditableElements: Array<JSX.Element>;\n\ttoolbarElement: JSX.Element;\n\tdata: Record<string, string>;\n\tsetData: Dispatch<SetStateAction<Record<string, string>>>;\n\tattributes: Record<string, Record<string, unknown>>;\n\tsetAttributes: Dispatch<SetStateAction<Record<string, Record<string, unknown>>>>;\n};\n","/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\n\nimport { useEffect, useRef, type MutableRefObject } from 'react';\n\n/**\n * Custom hook that returns a mutable ref object indicating whether the component is unmounted or not.\n *\n * @returns The mutable ref object.\n */\nexport const useIsUnmountedRef = (): MutableRefObject<boolean> => {\n\tconst mountedRef = useRef<boolean>( false );\n\n\tuseEffect( () => {\n\t\t// Prevent issues in strict mode.\n\t\tmountedRef.current = false;\n\n\t\treturn () => {\n\t\t\tmountedRef.current = true;\n\t\t};\n\t}, [] );\n\n\treturn mountedRef;\n};\n","/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\n\nimport { useState, useRef } from 'react';\nimport { uid, isSSR } from '@ckeditor/ckeditor5-integrations-common';\n\nimport { useIsUnmountedRef } from './useIsUnmountedRef.js';\nimport { useRefSafeCallback } from './useRefSafeCallback.js';\n\n/**\n * A hook that allows to execute an asynchronous function and provides the state of the execution.\n *\n * @param callback The asynchronous function to be executed.\n * @returns A tuple with the function that triggers the execution and the state of the execution.\n *\n * @example\n * ```tsx\n * const [ onFetchData, fetchDataStatus ] = useAsyncCallback( async () => {\n * \tconst response = await fetch( 'https://api.example.com/data' );\n * \tconst data = await response.json();\n * \treturn data;\n * } );\n *\n * return (\n * \t<div>\n * \t\t<button onClick={ onFetchData }>Fetch data</button>\n * \t\t{ fetchDataStatus.status === 'loading' && <p>Loading...</p> }\n * \t\t{ fetchDataStatus.status === 'success' && <pre>{ JSON.stringify( fetchDataStatus.data, null, 2 ) }</pre> }\n * \t\t{ fetchDataStatus.status === 'error' && <p>Error: { fetchDataStatus.error.message }</p> }\n * \t</div>\n * );\n * ```\n */\nexport const useAsyncCallback = <A extends Array<unknown>, R>(\n\tcallback: ( ...args: A ) => Promise<R>\n): AsyncCallbackHookResult<A, R> => {\n\t// The state of the asynchronous callback.\n\tconst [ asyncState, setAsyncState ] = useState<AsyncCallbackState<R>>( {\n\t\tstatus: 'idle'\n\t} );\n\n\t// A reference to the mounted state of the component.\n\tconst unmountedRef = useIsUnmountedRef();\n\n\t// A reference to the previous execution UUID. It is used to prevent race conditions between multiple executions\n\t// of the asynchronous function. If the UUID of the current execution is different than the UUID of the previous\n\t// execution, the state is not updated.\n\tconst prevExecutionUIDRef = useRef<string | null>( null );\n\n\t// The asynchronous executor function, which is a wrapped version of the original callback.\n\tconst asyncExecutor = useRefSafeCallback( async ( ...args: A ) => {\n\t\tif ( unmountedRef.current || isSSR() ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst currentExecutionUUID = uid();\n\t\tprevExecutionUIDRef.current = currentExecutionUUID;\n\n\t\ttry {\n\t\t\t// Prevent unnecessary state updates, keep loading state if the status is already 'loading'.\n\t\t\tif ( asyncState.status !== 'loading' ) {\n\t\t\t\tsetAsyncState( {\n\t\t\t\t\tstatus: 'loading'\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\t// Execute the asynchronous function.\n\t\t\tconst result = await callback( ...args );\n\n\t\t\t// Update the state if the component is still mounted and the execution UUID matches the previous one, otherwise\n\t\t\t// ignore the result and keep the previous state.\n\t\t\tif ( !unmountedRef.current && prevExecutionUIDRef.current === currentExecutionUUID ) {\n\t\t\t\tsetAsyncState( {\n\t\t\t\t\tstatus: 'success',\n\t\t\t\t\tdata: result\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\treturn result;\n\t\t} catch ( error: any ) {\n\t\t\tconsole.error( error );\n\n\t\t\t// Update the state if the component is still mounted and the execution UUID matches the previous one, otherwise\n\t\t\tif ( !unmountedRef.current && prevExecutionUIDRef.current === currentExecutionUUID ) {\n\t\t\t\tsetAsyncState( {\n\t\t\t\t\tstatus: 'error',\n\t\t\t\t\terror\n\t\t\t\t} );\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t} );\n\n\treturn [ asyncExecutor, asyncState ] as AsyncCallbackHookResult<A, R>;\n};\n\n/**\n * Represents the result of the `useAsyncCallback` hook.\n */\nexport type AsyncCallbackHookResult<A extends Array<unknown>, R> = [\n\t( ...args: A ) => Promise<R | null>,\n\tAsyncCallbackState<R>\n];\n\n/**\n * Represents the state of an asynchronous callback.\n */\nexport type AsyncCallbackState<T> =\n\t| {\n\t\tstatus: 'idle';\n\t}\n\t| {\n\t\tstatus: 'loading';\n\t}\n\t| {\n\t\tstatus: 'success';\n\t\tdata: T;\n\t}\n\t| {\n\t\tstatus: 'error';\n\t\terror: any;\n\t};\n","/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\n\nimport type { DependencyList } from 'react';\n\nimport { useAsyncCallback, type AsyncCallbackState } from './useAsyncCallback.js';\nimport { useInstantEffect } from './useInstantEffect.js';\n\n/**\n * A hook that allows to execute an asynchronous function and provides the state of the execution.\n * The asynchronous function is executed immediately after the component is mounted.\n *\n * @param callback The asynchronous function to be executed.\n * @param deps The dependency list.\n * @returns The state of the execution.\n *\n * @example\n * ```tsx\n * const asyncFetchState = useAsyncValue( async () => {\n * \tconst response = await fetch( 'https://api.example.com/data' );\n * \tconst data = await response.json();\n * \treturn data;\n * }, [] );\n *\n * if ( asyncFetchState.status === 'loading' ) {\n * \treturn <p>Loading...</p>;\n * }\n *\n * if ( asyncFetchState.status === 'success' ) {\n * \treturn <pre>{ JSON.stringify( asyncFetchState.data, null, 2 ) }</pre>;\n * }\n *\n * if ( asyncFetchState.status === 'error' ) {\n * \treturn <p>Error: { asyncFetchState.error.message }</p>;\n * }\n * ```\n */\nexport const useAsyncValue = <R>(\n\tcallback: () => Promise<R>,\n\tdeps: DependencyList\n): AsyncValueHookResult<R> => {\n\tconst [ asyncCallback, asyncState ] = useAsyncCallback( callback );\n\n\tuseInstantEffect( asyncCallback, deps );\n\n\t// There might be short delay between the effect and the state update.\n\t// So it is possible that the status is still 'idle' after the effect.\n\t// In such case, we should return 'loading' status because the effect is already queued to be executed.\n\tif ( asyncState.status === 'idle' ) {\n\t\treturn {\n\t\t\tstatus: 'loading'\n\t\t};\n\t}\n\n\treturn asyncState;\n};\n\n/**\n * The result of the `useAsyncValue` hook.\n */\nexport type AsyncValueHookResult<R> = Exclude<AsyncCallbackState<R>, { status: 'idle' }>;\n","/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\n\nimport {\n\tloadCKEditorCloud,\n\ttype CKEditorCloudConfig,\n\ttype CKEditorCloudResult\n} from '@ckeditor/ckeditor5-integrations-common';\n\nimport { useAsyncValue, type AsyncValueHookResult } from '../hooks/useAsyncValue.js';\n\n/**\n * Hook that loads CKEditor bundles from CDN.\n *\n * @template Config The type of the CKEditor Cloud configuration.\n * @param config The configuration of the hook.\n * @returns The state of async operation that resolves to the CKEditor bundles.\n * @example\n *\n * ```ts\n * const cloud = useCKEditorCloud( {\n * \tversion: '42.0.0',\n * \ttranslations: [ 'es', 'de' ],\n * \tpremium: true\n * } );\n *\n * if ( cloud.status === 'success' ) {\n * \tconst { ClassicEditor, Bold, Essentials } = cloud.CKEditor;\n * \tconst { SlashCommand } = cloud.CKEditorPremiumFeatures;\n * }\n * ```\n */\nexport default function useCKEditorCloud<Config extends CKEditorCloudConfig>(\n\tconfig: Config\n): CKEditorCloudHookResult<Config> {\n\t// Serialize the config to a string to fast compare if there was a change and re-render is needed.\n\tconst serializedConfigKey = JSON.stringify( config );\n\n\t// Fetch the CKEditor Cloud Services bundles on every modification of config.\n\tconst result = useAsyncValue(\n\t\tasync (): Promise<CKEditorCloudResult<Config>> => loadCKEditorCloud( config ),\n\t\t[ serializedConfigKey ]\n\t);\n\n\t// Expose a bit better API for the hook consumers, so they don't need to access the constructor through the `data` property.\n\tif ( result.status === 'success' ) {\n\t\treturn {\n\t\t\t...result.data,\n\t\t\tstatus: 'success'\n\t\t};\n\t}\n\n\treturn result;\n}\n\n/**\n * The result of the `useCKEditorCloud` hook. It changes success state to be more intuitive.\n */\ntype CKEditorCloudHookResult<Config extends CKEditorCloudConfig> =\n\t| Exclude<AsyncValueHookResult<CKEditorCloudResult<Config>>, { status: 'success' }>\n\t| ( CKEditorCloudResult<Config> & { status: 'success' } );\n","/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\n\nimport React, { type ReactNode, type ComponentType } from 'react';\nimport type {\n\tCKEditorCloudConfig,\n\tCKEditorCloudResult\n} from '@ckeditor/ckeditor5-integrations-common';\n\nimport useCKEditorCloud from './useCKEditorCloud.js';\n\n/**\n * HOC that injects the CKEditor Cloud integration into a component.\n *\n * @template A The type of the additional resources to load.\n * @param config The configuration of the CKEditor Cloud integration.\n * @returns A function that injects the CKEditor Cloud integration into a component.\n * @example\n\n * ```tsx\n * const withCKCloud = withCKEditorCloud( {\n * \tcloud: {\n * \t\tversion: '42.0.0',\n * \t\ttranslations: [ 'es', 'de' ],\n * \t\tpremium: true\n * \t}\n * } );\n *\n * const MyComponent = withCKCloud( ( { cloud } ) => {\n * \tconst { Paragraph } = cloud.CKEditor;\n * \tconst { SlashCommands } = cloud.CKEditorPremiumFeatures;\n * \tconst { YourPlugin } = cloud.CKPlugins;\n *\n * \treturn <div>CKEditor Cloud is loaded!</div>;\n * } );\n * ```\n */\nconst withCKEditorCloud = <Config extends CKEditorCloudConfig>( config: CKEditorCloudHocConfig<Config> ) =>\n\t<P extends object>(\n\t\tWrappedComponent: ComponentType<WithCKEditorCloudHocProps<Config> & P>\n\t): ComponentType<Omit<P, keyof WithCKEditorCloudHocProps<Config>>> => {\n\t\tconst ComponentWithCKEditorCloud = ( props: Omit<P, keyof WithCKEditorCloudHocProps<Config>> ) => {\n\t\t\tconst ckeditorCloudResult = useCKEditorCloud( config.cloud );\n\n\t\t\tswitch ( ckeditorCloudResult.status ) {\n\t\t\t\t// An error occurred while fetching the cloud information.\n\t\t\t\tcase 'error':\n\t\t\t\t\tif ( !config.renderError ) {\n\t\t\t\t\t\treturn 'Unable to load CKEditor Cloud data!';\n\t\t\t\t\t}\n\n\t\t\t\t\treturn config.renderError( ckeditorCloudResult.error );\n\n\t\t\t\t// The cloud information has been fetched successfully.\n\t\t\t\tcase 'success':\n\t\t\t\t\treturn <WrappedComponent {...props as P} cloud={ ckeditorCloudResult } />;\n\n\t\t\t\t// The cloud information is being fetched.\n\t\t\t\tdefault:\n\t\t\t\t\treturn config.renderLoader?.() ?? null;\n\t\t\t}\n\t\t};\n\n\t\tComponentWithCKEditorCloud.displayName = 'ComponentWithCKEditorCloud';\n\n\t\treturn ComponentWithCKEditorCloud;\n\t};\n\nexport default withCKEditorCloud;\n\n/**\n * Props injected by the `withCKEditorCloud` HOC.\n *\n * @template Config The configuration of the CKEditor Cloud integration.\n */\nexport type WithCKEditorCloudHocProps<Config extends CKEditorCloudConfig = CKEditorCloudConfig> = {\n\n\t/**\n\t * The result of the CKEditor Cloud integration.\n\t */\n\tcloud: CKEditorCloudResult<Config>;\n};\n\n/**\n * The configuration of the CKEditor Cloud integration.\n *\n * @template Config The configuration of the CKEditor Cloud integration.\n */\ntype CKEditorCloudHocConfig<Config extends CKEditorCloudConfig> = {\n\n\t/**\n\t * The configuration of the CKEditor Cloud integration.\n\t */\n\tcloud: Config;\n\n\t/**\n\t * Component to render while the cloud information is being fetched.\n\t */\n\trenderLoader?: () => ReactNode;\n\n\t/**\n\t * Component to render when an error occurs while fetching the cloud information.\n\t */\n\trenderError?: ( error: any ) => ReactNode;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}